<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pystablemotifs.succession API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pystablemotifs.succession</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import networkx as nx
import itertools as it
import matplotlib
import matplotlib.pyplot as plt

from copy import deepcopy

import pystablemotifs.reduction as sm_reduction
import pystablemotifs.format as sm_format
import pystablemotifs.drivers as sm_doi

class SuccessionDiagram:
    &#34;&#34;&#34;Class describing the succession diagram of a Boolean system. See, e.g.,
    Zanudo and Albert (2015) or Rozum et al. (2021).

    Attributes
    ----------
    motif_reduction_dict : dictionary
        MotifReduction-valued dictionary with integer (index) keys (see reduction.py).
    digraph : networkx.DiGraph
        Topological structure of hte succession diagram. Nodes are integers that
        align with the enteries of motif_reduction_dict.

    &#34;&#34;&#34;

    def __init__(self):
        self.motif_reduction_dict = {}
        self.digraph = nx.DiGraph()

    def get_motifs(self):
        &#34;&#34;&#34;Extract the stable motifs of a system and its reduced networks from its
        attractor repertoire. Notably, these include both the system&#39;s primary stable
        motifs and conditionally stable motifs (see, e.g., Deritei et al. 2019).

        Returns
        -------
        list of dictionaries
            Stable motifs that appear in the system or during reduction (in no
            particular order).

        &#34;&#34;&#34;
        SM_set = set([])
        for reduction in self.motif_reduction_dict.values():
            if len(reduction.motif_history)&gt;0:
                SM_set.add(frozenset(reduction.motif_history[-1].items()))
        return [dict(s) for s in SM_set]

    def find_motif_permutation(self,motif_history):
        &#34;&#34;&#34;Check whether some permutation of the input motif_history is already
        represented in the succession diagram. If so, return the preexisting
        reduction&#39;s index and the permutation that maps between the two histories.

        Parameters
        ----------
        motif_history : list of partial state dictionaries
            Stable motifs that can lock in to give a given reduced network (in
            order).

        Returns
        -------
        reduction_index : int
            Index of the preexisting reduced network. This value is None if no such
            reduced network exists.
        permutation : list of int
            Permutation that maps the preexisting history to the input history.
            This value is None if no such history exists.

        &#34;&#34;&#34;
        for reduction_index,mr in self.motif_reduction_dict.items():
            if len(mr.motif_history) == len(motif_history):
                if all([x in mr.motif_history for x in motif_history]):
                    permutation = []
                    for x in motif_history:
                        permutation.append(mr.motif_history.index(x))
                    return reduction_index,permutation # We already have an equivalent motif in the list
        return None,None

    def add_motif_permutation(self,reduction_index,permutation):
        &#34;&#34;&#34;Adds a permutation of a preexisting stable motif history to a precomputed
        MotifReduction object.

        Parameters
        ----------
        reduction_index : int
            Index of the preexisting reduced network.
        permutation : list of int
            Permutation that maps the preexisting history to the input history.

        &#34;&#34;&#34;
        self.motif_reduction_dict[reduction_index].merged_history_permutations.append(permutation)
        for child in nx.topological_sort(self.digraph):
            for parent in self.digraph.predecessors(child):
                for parent_perm,child_perm in it.product(
                    self.motif_reduction_dict[parent].merged_history_permutations,
                    self.motif_reduction_dict[child].merged_history_permutations):
                    new_perm = child_perm.copy()
                    for i,p in enumerate(parent_perm):
                        new_perm[i] = child_perm[p]
                    if not new_perm in self.motif_reduction_dict[child].merged_history_permutations:
                        self.motif_reduction_dict[child].merged_history_permutations.append(new_perm)

    def find_equivalent_reduction(self,fixed):
        &#34;&#34;&#34;Extracts the MotifReduction object that has the frozen node values
        specified by fixed, if such an object exists (returns None otherwise).

        Parameters
        ----------
        fixed : partial state dictionary
            Nodes values that have been fixed and reduced by stable motifs and their
            logical domain of influence.

        Returns
        -------
        MotifReduction
            Reduced network that has the frozen node values specified by fixed,
            if such an object exists (returns None otherwise).

        &#34;&#34;&#34;
        for reduction in self.motif_reduction_dict.values():
            if reduction.logically_fixed_nodes == fixed:
                return reduction
        return None

    def add_motif_reduction(self,motif_reduction):
        &#34;&#34;&#34;Inserts a given MotifReduction into the succession diagram. Does not
        check for consistency, but will insert a properly constructed MotifReduction
        into the correct place in the diagram.

        Parameters
        ----------
        motif_reduction : MotifReduction
            Reduced network to be appended to the succession diagram.

        &#34;&#34;&#34;
        if self.motif_reduction_dict == {}:
            self.unreduced_primes = motif_reduction.reduced_primes

        # note: N is computed BEFORE the new reduction is added,
        # so it will be the reduction index AFTER the reduction is added.
        N = len(self.motif_reduction_dict)
        new_set = set([frozenset(tuple(x.items())) for x in motif_reduction.motif_history])
        if N == 0:
            self.digraph.add_node(0)
        else:
            for i,reduction in self.motif_reduction_dict.items():
                old_set = set([frozenset(tuple(x.items())) for x in reduction.motif_history])

                # see if we&#39;re adding a parent of an existing reduction
                if len(old_set) == len(new_set) + 1:
                    diff_set = old_set - new_set
                    if len(diff_set) == 1:
                        missing_motif = dict(diff_set.pop())
                        if missing_motif in motif_reduction.stable_motifs:
                            self.digraph.add_edge(N,i)
                # see if we&#39;re adding a child of an existing reduction
                elif len(old_set) == len(new_set) - 1:
                    diff_set = new_set - old_set
                    if len(diff_set) == 1:
                        missing_motif = dict(diff_set.pop())
                        if missing_motif in reduction.stable_motifs or len(new_set) == 1: # valid motif OR source combination
                            self.digraph.add_edge(i,N)

        self.motif_reduction_dict[N] = motif_reduction
        self.add_motif_permutation(N,list(range(len(motif_reduction.motif_history))))

    def reductions_indices_with_states(self,logically_fixed,optimize=True):
        &#34;&#34;&#34;Find all reductions (by index) that have the nodes states specified
        logically fixed.

        Parameters
        ----------
        logically_fixed : partial state dictionary
            Nodes states that should be fixed in all returned network reductions.
        optimize : bool
            Whether to remove reduced networks that are subnetworks of valid
            reductions. This is generally recommended so as to obtain the most
            parsimonious control strategies (the default is True).

        Returns
        -------
        list of int
            Indices of reduced networks that have the appropriate fixed states.

        &#34;&#34;&#34;
        if not optimize:
            # NOTE: This finds all reductions, not just those closest to the root
            target_indices = []
            for i,reduction in self.motif_reduction_dict.items():
                if logically_fixed.items() &lt;= reduction.logically_fixed_nodes.items():
                    target_indices.append(i)
            return target_indices
        else:
            # The unoptimized result
            target_indices_unoptimized = self.reductions_indices_with_states(logically_fixed,optimize=False)
            target_indices_all = target_indices_unoptimized.copy()

            # Add nodes that inevitably reach nodes in the unoptimized result
            nodes_to_consider = [x for x in self.digraph if (not x in target_indices_all
                and self.motif_reduction_dict[x].terminal == &#34;no&#34;)]
            for i in nodes_to_consider:
                bad_sinks = [x for x in nx.descendants(self.digraph,i) | set([i]) if (
                    not self.motif_reduction_dict[x].terminal == &#34;no&#34; # is a sink and . . .
                    and not x in target_indices_unoptimized)] # does not have the right nodes fixed

                if len(bad_sinks) == 0:
                    target_indices_all.append(i)

            # remove nodes who have ancestors that would work instead, as those
            # will be closer to the root and easier to control
            target_indices = []
            for target_index in target_indices_all:
                if set(nx.ancestors(self.digraph,target_index)) &amp; set(target_indices_all) == set():
                    target_indices.append(target_index)

            return target_indices

    def reduction_drivers(self,target_index,method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None):
        &#34;&#34;&#34;Find control strategies that lead to the reduced network specified by
        the target index. Several control strategies are implemented. See
        succession.SuccessionDiagram.reprogram_to_trap_spaces for a detailed
        description of control methods available. Generally, this method should
        not be used directly. Instead, use reprogram_to_trap_spaces.

        Parameters
        ----------
        target_index : int
            Index of the target reduced network.
        method : str
            One of &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39;. See
            succession.SuccessionDiagram.reprogram_to_trap_spaces for details.
        max_drivers : int
            Maximum number of driver nodes to consider (not used in GRASP methods).
            If none, the upper limit is given by the number of free variables
            (the default is None).
        GRASP_iterations : int
            Number of times to construct GRASP driver sets; only used in GRASP
            methods. If none, the number of iterations is chosen based on the
            network size (the default is None).

        Returns
        -------
        list
            Control strategies found; interpretation depends on method selected
            See succession.SuccessionDiagram.reprogram_to_trap_spaces for details.

        &#34;&#34;&#34;
        methods = [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
        assert method in methods, &#39; &#39;.join([&#34;method argument of reduction_drivers must be among&#34;,str(methods)])
        drivers = []
        for path in nx.all_simple_paths(self.digraph,0,target_index):
            path_motif_history=[]
            path_drivers = []
            for ind in path:
                if ind == 0:
                    ind_prev = ind
                    continue
                path_motif_history += [x for x in self.motif_reduction_dict[ind].motif_history if not x in path_motif_history]

                if method == &#39;internal&#39;:
                    history_drivers = sm_doi.internal_drivers(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        max_drivers=max_drivers)
                elif method == &#39;GRASP&#39;:
                    history_drivers = sm_doi.GRASP(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        GRASP_iterations = GRASP_iterations)
                    if len(history_drivers) == 0:
                        history_drivers = [path_motif_history[-1]]
                elif method == &#39;minimal&#39;:
                    history_drivers = sm_doi.minimal_drivers(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        max_drivers=max_drivers)

                path_drivers.append(history_drivers)

                ind_prev = ind
            if method == &#39;internal&#39;:
                # merge control sets along the path
                for control_sequence in it.product(*path_drivers):
                    control_set = {k:v for x in control_sequence for k,v in x.items()}
                    if not control_set in drivers:
                        drivers.append(control_set)
            elif method == &#39;minimal&#39; or method == &#39;GRASP&#39;:
                drivers.append(path_drivers)
        return drivers

    def reprogram_to_trap_spaces(self,logically_fixed,target_method=&#39;history&#39;,driver_method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None,GRASP_score_override=None):
        &#34;&#34;&#34;Find driver sets that lead to fixing the node states specified.

        Parameters
        ----------
        logically_fixed : partial state dictionary
            Targeted fixed nodes.
        target_method : str
            Either &#39;history&#39; or &#39;merge&#39;; see Notes below for details.
        driver_method : str
            Either &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39; see Notes below for details.
        max_drivers : int
            Maximum number of driver nodes to consider (not used in GRASP methods).
            If none, the upper limit is given by the number of free variables
            (the default is None).
        GRASP_iterations : int
            Number of times to construct GRASP driver sets; only used in GRASP
            methods. If none, the number of iterations is chosen based on the
            network size (the default is None).
        GRASP_score_override : function
            Optional heuristic score function override (see drivers.GRASP
            for details). Only used in GRASP methods (the default is None).

        Returns
        -------
        list
            Control strategies found; interpretation depends on method selected
            See Notes below for details.

        Notes
        -----
        The various combinations of target_method and driver_method options result
        in different control strategies, which are outlined below.

        target_method = history, driver_method = internal:
        Finds all shortest stable motif histories that result in the target node states
        being logically fixed. Each stable motif is searched for internal driver nodes.
        The resulting internal drivers are combined into a single  control set. The
        return value consists of all such control sets for all  stable motif histories.
        Each control set eventually becomes self-sustaining.

        target_method = history, driver_method = minimal:
        Similar to the history method, except the search for stable motif drivers
        includes external driver nodes for the motif and does not extend to driver sets
        of larger size once one driver set has been found for a motif. Because the
        search includes external driver nodes, special care must be taken in interpreting
        the effect of the drivers, as their influence may impact the effect of motifs
        stabilizing. Thus, the control is only guaranteed to work if the interventions
        are temporary and implemented in the order specified by the motif history.

        For this reason, the output consists of lists of ordered interventions.
        Each element of the return value is a list of lists of dictionaries. Each
        element of the return value represents a control strategy. To implement such
        a strategy, select a dictionary from the first element of the strategy and
        fix the node states it specifies until their influence has propagated through
        the system. Then repeat this process iteratively for each element of the strategy
        list, in order. For example, if
        nonredundant_drivers = [ [[{&#39;xD&#39;:1,&#39;xE=1&#39;}]], [[{&#39;xA&#39;:1},{&#39;xB&#39;:1}],[{&#39;xC&#39;:1}]] ]
        then there are two control strategies available:
        1) fix xD=xE=1 temporarily and
        2) first fix either xA=1 or xB=1 temporarily, then fix xC=1 temporarily.

        target_method = history, driver_method = GRASP:
        The same as history, minimal, except external driver nodes are searched for
        using the GRASP algorithm using GRASP_iterations iterations.

        target_method = merge, driver_method = internal:
        Finds all shortest stable motif histories that result in the target node states
        being logically fixed. All node states in the motifs in the history are merged
        into a stable module dictionary. This is then searched for internal driver
        nodes. Each element of the return value is a dictionary corresponding to a
        control set. Each control set eventually becomes self-sustaining.

        target_method = merge, driver_method = minimal:
        Similar to the merge method, except the search for drivers is conducted over
        all nodes, not just those internal to the merged stable module. Furthermore,
        the search is truncated when a control set is found such that the search does
        not proceed to driver sets larger than the smallest found. Each element of
        the return value is a dictionary corresponding to a control set. The control
        sets are only guaranteed to result in activation of the target if they are
        temporary interventions.

        target_method = merge, driver_method = GRASP:
        The same as merge, minimal, except external driver nodes are searched for
        using the GRASP algorithm using GRASP_iterations iterations.

        &#34;&#34;&#34;

        #methods = [&#39;history&#39;,&#39;merge&#39;,&#39;minimal_history&#39;,&#39;minimal_merge&#39;]
        target_methods = [&#39;history&#39;,&#39;merge&#39;]
        driver_methods= [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
        assert target_method in target_methods, &#39; &#39;.join([&#34;target_method argument of reprogram_to_trap_spaces must be among&#34;,str(target_methods)])
        assert driver_method in driver_methods, &#39; &#39;.join([&#34;driver_method argument of reprogram_to_trap_spaces must be among&#34;,str(driver_methods)])
        drivers = []

        if driver_method == &#39;GRASP&#39; and GRASP_iterations is None:
            if target_method == &#39;merge&#39;:
                GRASP_iterations = len(self.unreduced_primes)**2
            if target_method == &#39;history&#39;:
                GRASP_iterations = 2*len(self.unreduced_primes)

        target_indices = self.reductions_indices_with_states(logically_fixed)

        if target_method == &#39;history&#39;:
            for target_index in target_indices:
                drivers += self.reduction_drivers(target_index,max_drivers=max_drivers,GRASP_iterations=GRASP_iterations,method=driver_method)
        elif target_method == &#39;merge&#39;:
            for target_index in target_indices:
                target_history = self.motif_reduction_dict[target_index].motif_history
                motif_merger = {k:v for d in target_history for k,v in d.items()}

                # Because we are potentially dealing with external drivers, we
                # want to make sure the external drivers do not interfere with
                # the motif&#39;s ability to drive downstream targets
                # if driver_method != &#39;internal&#39;:
                #     motif_merger.update(logically_fixed)

                if driver_method == &#39;GRASP&#39;:
                    merger_drivers = sm_doi.GRASP(motif_merger,self.unreduced_primes,GRASP_iterations)
                    if len(merger_drivers) == 0:
                        merger_drivers = [motif_merger.copy()]
                elif driver_method == &#39;minimal&#39;:
                    merger_drivers = sm_doi.minimal_drivers(motif_merger,
                        self.unreduced_primes,max_drivers=max_drivers)
                elif driver_method == &#39;internal&#39;:
                    merger_drivers = sm_doi.internal_drivers(motif_merger,
                        self.unreduced_primes,max_drivers=max_drivers)

                drivers += [x for x in merger_drivers if not x in drivers]

        drivers = sorted(drivers,key=lambda x: len(x))

        # Next, we remove redundant control sets.
        # In the minimal_history scheme, a set x is redundant if there is a y
        # that contains all control sets of x in the same order.
        # In all other schemes, x is redundant if it is a subset of some y.
        nonredundant_drivers = []
        if target_method == &#39;history&#39; and (driver_method == &#39;minimal&#39; or driver_method == &#39;GRASP&#39;):
            nonredundant_drivers = []
            for x in drivers: # drivers is sorted from fewest timesteps to most
                add_x = True
                for y in nonredundant_drivers: # note: len(y) &lt;= len(x)
                    for offset in range(len(x)-len(y)+1):
                        for i in range(len(y)):
                            # want to check that x[i+offset] is a special case of y[i]
                            for j in range(len(y)):
                                xset = set([frozenset(tuple(xdict.items())) for xdict in x[i+offset]])
                                yset = set([frozenset(tuple(xdict.items())) for xdict in y[i]])
                                if yset &lt;= xset:
                                    add_x = False
                                    break
                            if not add_x: break
                        if not add_x: break
                    if not add_x: break
                if add_x:
                    nonredundant_drivers.append(x)

        else:
            for i in range(len(drivers)):
                use_i = True
                for j in range(i): # i &gt; j
                    if drivers[i].items() &gt;= drivers[j].items():
                        use_i = False
                        break
                if use_i: nonredundant_drivers.append(drivers[i])

        return nonredundant_drivers

def build_succession_diagram(primes, fixed=None, motif_history=None, diagram=None, merge_equivalent_motifs=True,max_simulate_size=20,prioritize_source_motifs=True,max_stable_motifs=10000, MPBN_update=False):
    &#34;&#34;&#34;Recursively construct a succession diagram from the input update rules.
    Generally, it is preferable to construct this from within the AttractorRepertoire
    class (using, e.g., AttractorRepertoire.from_primes).

    Parameters
    ----------
    primes : pyboolnet primes dictionary
        Update rules.
    fixed : partial state dictionary
        Used only for recursion. Specifies nodes to be fixed in the next reduced
        network to be added to the diagram.
    motif_history : list of partial state dictionaries
        Used only for recursion. Specifies stable motif history for the next reduced
        network to be added to the diagram.
    diagram : SuccessionDiagram
        Used only for recursion. The SuccessionDiagram object that is under
        construction.
    merge_equivalent_motifs : bool
        If False, equivalent reduced networks have their data recomputed and
        copied. Making this False is only recommended if the succession diagram
        must be represented in a form that has no feedforward loops; making this
        True provides large computational advantages, both in terms of speed and
        memory usage (the default is True).
    max_simulate_size : int
        Maximum number of variables for which to brute-force build a state
        transition graph (the default is 20).
    prioritize_source_motifs : bool
        Whether source nodes should be considered first (the default is True).
    max_stable_motifs : int
        Maximum number of output lines for pyboolnet to process from the
        AspSolver (the default is 10000).
    MPBN_update : bool
        Whether MBPN update is used instead of general asynchronous update
        (the default is False).

    Returns
    -------
    SuccessionDiagram
        The succession diagram for the input update rules.

    &#34;&#34;&#34;

    if diagram is None:
        diagram = SuccessionDiagram()

    if fixed is None:
        fixed = {}

    myMotifReductionToCopy = diagram.find_equivalent_reduction(fixed)

    if myMotifReductionToCopy is None:
        myMotifReduction=sm_reduction.MotifReduction(motif_history,fixed.copy(),primes,max_simulate_size=max_simulate_size,prioritize_source_motifs=prioritize_source_motifs,max_stable_motifs=max_stable_motifs,MPBN_update=MPBN_update)
    else:
        myMotifReduction = deepcopy(myMotifReductionToCopy)
        myMotifReduction.motif_history = motif_history.copy()
        myMotifReduction.merged_history_permutations = []

    diagram.add_motif_reduction(myMotifReduction)

    # Prioritize source nodes
    if myMotifReduction.merged_source_motifs is None:
        stable_motif_list = myMotifReduction.stable_motifs
    else:
        stable_motif_list = myMotifReduction.merged_source_motifs

    for sm in stable_motif_list:
        if merge_equivalent_motifs:
            perm_index,perm = diagram.find_motif_permutation(myMotifReduction.motif_history+[sm])
            if not perm_index is None:
                diagram.add_motif_permutation(perm_index,perm)
        if not merge_equivalent_motifs or perm_index is None:
            np,fixed2 = sm_reduction.reduce_primes(sm,primes)
            fixed3 = fixed.copy()
            fixed3.update(fixed2)
            diagram = build_succession_diagram(np,fixed3,myMotifReduction.motif_history+[sm],
                diagram, merge_equivalent_motifs=merge_equivalent_motifs,
                max_simulate_size=max_simulate_size,
                max_stable_motifs=max_stable_motifs,
                prioritize_source_motifs=prioritize_source_motifs,
                MPBN_update=MPBN_update)
    return diagram</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pystablemotifs.succession.build_succession_diagram"><code class="name flex">
<span>def <span class="ident">build_succession_diagram</span></span>(<span>primes, fixed=None, motif_history=None, diagram=None, merge_equivalent_motifs=True, max_simulate_size=20, prioritize_source_motifs=True, max_stable_motifs=10000, MPBN_update=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively construct a succession diagram from the input update rules.
Generally, it is preferable to construct this from within the AttractorRepertoire
class (using, e.g., AttractorRepertoire.from_primes).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>primes</code></strong> :&ensp;<code>pyboolnet primes dictionary</code></dt>
<dd>Update rules.</dd>
<dt><strong><code>fixed</code></strong> :&ensp;<code>partial state dictionary</code></dt>
<dd>Used only for recursion. Specifies nodes to be fixed in the next reduced
network to be added to the diagram.</dd>
<dt><strong><code>motif_history</code></strong> :&ensp;<code>list</code> of <code>partial state dictionaries</code></dt>
<dd>Used only for recursion. Specifies stable motif history for the next reduced
network to be added to the diagram.</dd>
<dt><strong><code>diagram</code></strong> :&ensp;<code><a title="pystablemotifs.succession.SuccessionDiagram" href="#pystablemotifs.succession.SuccessionDiagram">SuccessionDiagram</a></code></dt>
<dd>Used only for recursion. The SuccessionDiagram object that is under
construction.</dd>
<dt><strong><code>merge_equivalent_motifs</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False, equivalent reduced networks have their data recomputed and
copied. Making this False is only recommended if the succession diagram
must be represented in a form that has no feedforward loops; making this
True provides large computational advantages, both in terms of speed and
memory usage (the default is True).</dd>
<dt><strong><code>max_simulate_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of variables for which to brute-force build a state
transition graph (the default is 20).</dd>
<dt><strong><code>prioritize_source_motifs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether source nodes should be considered first (the default is True).</dd>
<dt><strong><code>max_stable_motifs</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of output lines for pyboolnet to process from the
AspSolver (the default is 10000).</dd>
<dt><strong><code>MPBN_update</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether MBPN update is used instead of general asynchronous update
(the default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pystablemotifs.succession.SuccessionDiagram" href="#pystablemotifs.succession.SuccessionDiagram">SuccessionDiagram</a></code></dt>
<dd>The succession diagram for the input update rules.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_succession_diagram(primes, fixed=None, motif_history=None, diagram=None, merge_equivalent_motifs=True,max_simulate_size=20,prioritize_source_motifs=True,max_stable_motifs=10000, MPBN_update=False):
    &#34;&#34;&#34;Recursively construct a succession diagram from the input update rules.
    Generally, it is preferable to construct this from within the AttractorRepertoire
    class (using, e.g., AttractorRepertoire.from_primes).

    Parameters
    ----------
    primes : pyboolnet primes dictionary
        Update rules.
    fixed : partial state dictionary
        Used only for recursion. Specifies nodes to be fixed in the next reduced
        network to be added to the diagram.
    motif_history : list of partial state dictionaries
        Used only for recursion. Specifies stable motif history for the next reduced
        network to be added to the diagram.
    diagram : SuccessionDiagram
        Used only for recursion. The SuccessionDiagram object that is under
        construction.
    merge_equivalent_motifs : bool
        If False, equivalent reduced networks have their data recomputed and
        copied. Making this False is only recommended if the succession diagram
        must be represented in a form that has no feedforward loops; making this
        True provides large computational advantages, both in terms of speed and
        memory usage (the default is True).
    max_simulate_size : int
        Maximum number of variables for which to brute-force build a state
        transition graph (the default is 20).
    prioritize_source_motifs : bool
        Whether source nodes should be considered first (the default is True).
    max_stable_motifs : int
        Maximum number of output lines for pyboolnet to process from the
        AspSolver (the default is 10000).
    MPBN_update : bool
        Whether MBPN update is used instead of general asynchronous update
        (the default is False).

    Returns
    -------
    SuccessionDiagram
        The succession diagram for the input update rules.

    &#34;&#34;&#34;

    if diagram is None:
        diagram = SuccessionDiagram()

    if fixed is None:
        fixed = {}

    myMotifReductionToCopy = diagram.find_equivalent_reduction(fixed)

    if myMotifReductionToCopy is None:
        myMotifReduction=sm_reduction.MotifReduction(motif_history,fixed.copy(),primes,max_simulate_size=max_simulate_size,prioritize_source_motifs=prioritize_source_motifs,max_stable_motifs=max_stable_motifs,MPBN_update=MPBN_update)
    else:
        myMotifReduction = deepcopy(myMotifReductionToCopy)
        myMotifReduction.motif_history = motif_history.copy()
        myMotifReduction.merged_history_permutations = []

    diagram.add_motif_reduction(myMotifReduction)

    # Prioritize source nodes
    if myMotifReduction.merged_source_motifs is None:
        stable_motif_list = myMotifReduction.stable_motifs
    else:
        stable_motif_list = myMotifReduction.merged_source_motifs

    for sm in stable_motif_list:
        if merge_equivalent_motifs:
            perm_index,perm = diagram.find_motif_permutation(myMotifReduction.motif_history+[sm])
            if not perm_index is None:
                diagram.add_motif_permutation(perm_index,perm)
        if not merge_equivalent_motifs or perm_index is None:
            np,fixed2 = sm_reduction.reduce_primes(sm,primes)
            fixed3 = fixed.copy()
            fixed3.update(fixed2)
            diagram = build_succession_diagram(np,fixed3,myMotifReduction.motif_history+[sm],
                diagram, merge_equivalent_motifs=merge_equivalent_motifs,
                max_simulate_size=max_simulate_size,
                max_stable_motifs=max_stable_motifs,
                prioritize_source_motifs=prioritize_source_motifs,
                MPBN_update=MPBN_update)
    return diagram</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pystablemotifs.succession.SuccessionDiagram"><code class="flex name class">
<span>class <span class="ident">SuccessionDiagram</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class describing the succession diagram of a Boolean system. See, e.g.,
Zanudo and Albert (2015) or Rozum et al. (2021).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>motif_reduction_dict</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>MotifReduction-valued dictionary with integer (index) keys (see reduction.py).</dd>
<dt><strong><code>digraph</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>Topological structure of hte succession diagram. Nodes are integers that
align with the enteries of motif_reduction_dict.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SuccessionDiagram:
    &#34;&#34;&#34;Class describing the succession diagram of a Boolean system. See, e.g.,
    Zanudo and Albert (2015) or Rozum et al. (2021).

    Attributes
    ----------
    motif_reduction_dict : dictionary
        MotifReduction-valued dictionary with integer (index) keys (see reduction.py).
    digraph : networkx.DiGraph
        Topological structure of hte succession diagram. Nodes are integers that
        align with the enteries of motif_reduction_dict.

    &#34;&#34;&#34;

    def __init__(self):
        self.motif_reduction_dict = {}
        self.digraph = nx.DiGraph()

    def get_motifs(self):
        &#34;&#34;&#34;Extract the stable motifs of a system and its reduced networks from its
        attractor repertoire. Notably, these include both the system&#39;s primary stable
        motifs and conditionally stable motifs (see, e.g., Deritei et al. 2019).

        Returns
        -------
        list of dictionaries
            Stable motifs that appear in the system or during reduction (in no
            particular order).

        &#34;&#34;&#34;
        SM_set = set([])
        for reduction in self.motif_reduction_dict.values():
            if len(reduction.motif_history)&gt;0:
                SM_set.add(frozenset(reduction.motif_history[-1].items()))
        return [dict(s) for s in SM_set]

    def find_motif_permutation(self,motif_history):
        &#34;&#34;&#34;Check whether some permutation of the input motif_history is already
        represented in the succession diagram. If so, return the preexisting
        reduction&#39;s index and the permutation that maps between the two histories.

        Parameters
        ----------
        motif_history : list of partial state dictionaries
            Stable motifs that can lock in to give a given reduced network (in
            order).

        Returns
        -------
        reduction_index : int
            Index of the preexisting reduced network. This value is None if no such
            reduced network exists.
        permutation : list of int
            Permutation that maps the preexisting history to the input history.
            This value is None if no such history exists.

        &#34;&#34;&#34;
        for reduction_index,mr in self.motif_reduction_dict.items():
            if len(mr.motif_history) == len(motif_history):
                if all([x in mr.motif_history for x in motif_history]):
                    permutation = []
                    for x in motif_history:
                        permutation.append(mr.motif_history.index(x))
                    return reduction_index,permutation # We already have an equivalent motif in the list
        return None,None

    def add_motif_permutation(self,reduction_index,permutation):
        &#34;&#34;&#34;Adds a permutation of a preexisting stable motif history to a precomputed
        MotifReduction object.

        Parameters
        ----------
        reduction_index : int
            Index of the preexisting reduced network.
        permutation : list of int
            Permutation that maps the preexisting history to the input history.

        &#34;&#34;&#34;
        self.motif_reduction_dict[reduction_index].merged_history_permutations.append(permutation)
        for child in nx.topological_sort(self.digraph):
            for parent in self.digraph.predecessors(child):
                for parent_perm,child_perm in it.product(
                    self.motif_reduction_dict[parent].merged_history_permutations,
                    self.motif_reduction_dict[child].merged_history_permutations):
                    new_perm = child_perm.copy()
                    for i,p in enumerate(parent_perm):
                        new_perm[i] = child_perm[p]
                    if not new_perm in self.motif_reduction_dict[child].merged_history_permutations:
                        self.motif_reduction_dict[child].merged_history_permutations.append(new_perm)

    def find_equivalent_reduction(self,fixed):
        &#34;&#34;&#34;Extracts the MotifReduction object that has the frozen node values
        specified by fixed, if such an object exists (returns None otherwise).

        Parameters
        ----------
        fixed : partial state dictionary
            Nodes values that have been fixed and reduced by stable motifs and their
            logical domain of influence.

        Returns
        -------
        MotifReduction
            Reduced network that has the frozen node values specified by fixed,
            if such an object exists (returns None otherwise).

        &#34;&#34;&#34;
        for reduction in self.motif_reduction_dict.values():
            if reduction.logically_fixed_nodes == fixed:
                return reduction
        return None

    def add_motif_reduction(self,motif_reduction):
        &#34;&#34;&#34;Inserts a given MotifReduction into the succession diagram. Does not
        check for consistency, but will insert a properly constructed MotifReduction
        into the correct place in the diagram.

        Parameters
        ----------
        motif_reduction : MotifReduction
            Reduced network to be appended to the succession diagram.

        &#34;&#34;&#34;
        if self.motif_reduction_dict == {}:
            self.unreduced_primes = motif_reduction.reduced_primes

        # note: N is computed BEFORE the new reduction is added,
        # so it will be the reduction index AFTER the reduction is added.
        N = len(self.motif_reduction_dict)
        new_set = set([frozenset(tuple(x.items())) for x in motif_reduction.motif_history])
        if N == 0:
            self.digraph.add_node(0)
        else:
            for i,reduction in self.motif_reduction_dict.items():
                old_set = set([frozenset(tuple(x.items())) for x in reduction.motif_history])

                # see if we&#39;re adding a parent of an existing reduction
                if len(old_set) == len(new_set) + 1:
                    diff_set = old_set - new_set
                    if len(diff_set) == 1:
                        missing_motif = dict(diff_set.pop())
                        if missing_motif in motif_reduction.stable_motifs:
                            self.digraph.add_edge(N,i)
                # see if we&#39;re adding a child of an existing reduction
                elif len(old_set) == len(new_set) - 1:
                    diff_set = new_set - old_set
                    if len(diff_set) == 1:
                        missing_motif = dict(diff_set.pop())
                        if missing_motif in reduction.stable_motifs or len(new_set) == 1: # valid motif OR source combination
                            self.digraph.add_edge(i,N)

        self.motif_reduction_dict[N] = motif_reduction
        self.add_motif_permutation(N,list(range(len(motif_reduction.motif_history))))

    def reductions_indices_with_states(self,logically_fixed,optimize=True):
        &#34;&#34;&#34;Find all reductions (by index) that have the nodes states specified
        logically fixed.

        Parameters
        ----------
        logically_fixed : partial state dictionary
            Nodes states that should be fixed in all returned network reductions.
        optimize : bool
            Whether to remove reduced networks that are subnetworks of valid
            reductions. This is generally recommended so as to obtain the most
            parsimonious control strategies (the default is True).

        Returns
        -------
        list of int
            Indices of reduced networks that have the appropriate fixed states.

        &#34;&#34;&#34;
        if not optimize:
            # NOTE: This finds all reductions, not just those closest to the root
            target_indices = []
            for i,reduction in self.motif_reduction_dict.items():
                if logically_fixed.items() &lt;= reduction.logically_fixed_nodes.items():
                    target_indices.append(i)
            return target_indices
        else:
            # The unoptimized result
            target_indices_unoptimized = self.reductions_indices_with_states(logically_fixed,optimize=False)
            target_indices_all = target_indices_unoptimized.copy()

            # Add nodes that inevitably reach nodes in the unoptimized result
            nodes_to_consider = [x for x in self.digraph if (not x in target_indices_all
                and self.motif_reduction_dict[x].terminal == &#34;no&#34;)]
            for i in nodes_to_consider:
                bad_sinks = [x for x in nx.descendants(self.digraph,i) | set([i]) if (
                    not self.motif_reduction_dict[x].terminal == &#34;no&#34; # is a sink and . . .
                    and not x in target_indices_unoptimized)] # does not have the right nodes fixed

                if len(bad_sinks) == 0:
                    target_indices_all.append(i)

            # remove nodes who have ancestors that would work instead, as those
            # will be closer to the root and easier to control
            target_indices = []
            for target_index in target_indices_all:
                if set(nx.ancestors(self.digraph,target_index)) &amp; set(target_indices_all) == set():
                    target_indices.append(target_index)

            return target_indices

    def reduction_drivers(self,target_index,method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None):
        &#34;&#34;&#34;Find control strategies that lead to the reduced network specified by
        the target index. Several control strategies are implemented. See
        succession.SuccessionDiagram.reprogram_to_trap_spaces for a detailed
        description of control methods available. Generally, this method should
        not be used directly. Instead, use reprogram_to_trap_spaces.

        Parameters
        ----------
        target_index : int
            Index of the target reduced network.
        method : str
            One of &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39;. See
            succession.SuccessionDiagram.reprogram_to_trap_spaces for details.
        max_drivers : int
            Maximum number of driver nodes to consider (not used in GRASP methods).
            If none, the upper limit is given by the number of free variables
            (the default is None).
        GRASP_iterations : int
            Number of times to construct GRASP driver sets; only used in GRASP
            methods. If none, the number of iterations is chosen based on the
            network size (the default is None).

        Returns
        -------
        list
            Control strategies found; interpretation depends on method selected
            See succession.SuccessionDiagram.reprogram_to_trap_spaces for details.

        &#34;&#34;&#34;
        methods = [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
        assert method in methods, &#39; &#39;.join([&#34;method argument of reduction_drivers must be among&#34;,str(methods)])
        drivers = []
        for path in nx.all_simple_paths(self.digraph,0,target_index):
            path_motif_history=[]
            path_drivers = []
            for ind in path:
                if ind == 0:
                    ind_prev = ind
                    continue
                path_motif_history += [x for x in self.motif_reduction_dict[ind].motif_history if not x in path_motif_history]

                if method == &#39;internal&#39;:
                    history_drivers = sm_doi.internal_drivers(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        max_drivers=max_drivers)
                elif method == &#39;GRASP&#39;:
                    history_drivers = sm_doi.GRASP(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        GRASP_iterations = GRASP_iterations)
                    if len(history_drivers) == 0:
                        history_drivers = [path_motif_history[-1]]
                elif method == &#39;minimal&#39;:
                    history_drivers = sm_doi.minimal_drivers(path_motif_history[-1],
                        self.motif_reduction_dict[ind_prev].reduced_primes,
                        max_drivers=max_drivers)

                path_drivers.append(history_drivers)

                ind_prev = ind
            if method == &#39;internal&#39;:
                # merge control sets along the path
                for control_sequence in it.product(*path_drivers):
                    control_set = {k:v for x in control_sequence for k,v in x.items()}
                    if not control_set in drivers:
                        drivers.append(control_set)
            elif method == &#39;minimal&#39; or method == &#39;GRASP&#39;:
                drivers.append(path_drivers)
        return drivers

    def reprogram_to_trap_spaces(self,logically_fixed,target_method=&#39;history&#39;,driver_method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None,GRASP_score_override=None):
        &#34;&#34;&#34;Find driver sets that lead to fixing the node states specified.

        Parameters
        ----------
        logically_fixed : partial state dictionary
            Targeted fixed nodes.
        target_method : str
            Either &#39;history&#39; or &#39;merge&#39;; see Notes below for details.
        driver_method : str
            Either &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39; see Notes below for details.
        max_drivers : int
            Maximum number of driver nodes to consider (not used in GRASP methods).
            If none, the upper limit is given by the number of free variables
            (the default is None).
        GRASP_iterations : int
            Number of times to construct GRASP driver sets; only used in GRASP
            methods. If none, the number of iterations is chosen based on the
            network size (the default is None).
        GRASP_score_override : function
            Optional heuristic score function override (see drivers.GRASP
            for details). Only used in GRASP methods (the default is None).

        Returns
        -------
        list
            Control strategies found; interpretation depends on method selected
            See Notes below for details.

        Notes
        -----
        The various combinations of target_method and driver_method options result
        in different control strategies, which are outlined below.

        target_method = history, driver_method = internal:
        Finds all shortest stable motif histories that result in the target node states
        being logically fixed. Each stable motif is searched for internal driver nodes.
        The resulting internal drivers are combined into a single  control set. The
        return value consists of all such control sets for all  stable motif histories.
        Each control set eventually becomes self-sustaining.

        target_method = history, driver_method = minimal:
        Similar to the history method, except the search for stable motif drivers
        includes external driver nodes for the motif and does not extend to driver sets
        of larger size once one driver set has been found for a motif. Because the
        search includes external driver nodes, special care must be taken in interpreting
        the effect of the drivers, as their influence may impact the effect of motifs
        stabilizing. Thus, the control is only guaranteed to work if the interventions
        are temporary and implemented in the order specified by the motif history.

        For this reason, the output consists of lists of ordered interventions.
        Each element of the return value is a list of lists of dictionaries. Each
        element of the return value represents a control strategy. To implement such
        a strategy, select a dictionary from the first element of the strategy and
        fix the node states it specifies until their influence has propagated through
        the system. Then repeat this process iteratively for each element of the strategy
        list, in order. For example, if
        nonredundant_drivers = [ [[{&#39;xD&#39;:1,&#39;xE=1&#39;}]], [[{&#39;xA&#39;:1},{&#39;xB&#39;:1}],[{&#39;xC&#39;:1}]] ]
        then there are two control strategies available:
        1) fix xD=xE=1 temporarily and
        2) first fix either xA=1 or xB=1 temporarily, then fix xC=1 temporarily.

        target_method = history, driver_method = GRASP:
        The same as history, minimal, except external driver nodes are searched for
        using the GRASP algorithm using GRASP_iterations iterations.

        target_method = merge, driver_method = internal:
        Finds all shortest stable motif histories that result in the target node states
        being logically fixed. All node states in the motifs in the history are merged
        into a stable module dictionary. This is then searched for internal driver
        nodes. Each element of the return value is a dictionary corresponding to a
        control set. Each control set eventually becomes self-sustaining.

        target_method = merge, driver_method = minimal:
        Similar to the merge method, except the search for drivers is conducted over
        all nodes, not just those internal to the merged stable module. Furthermore,
        the search is truncated when a control set is found such that the search does
        not proceed to driver sets larger than the smallest found. Each element of
        the return value is a dictionary corresponding to a control set. The control
        sets are only guaranteed to result in activation of the target if they are
        temporary interventions.

        target_method = merge, driver_method = GRASP:
        The same as merge, minimal, except external driver nodes are searched for
        using the GRASP algorithm using GRASP_iterations iterations.

        &#34;&#34;&#34;

        #methods = [&#39;history&#39;,&#39;merge&#39;,&#39;minimal_history&#39;,&#39;minimal_merge&#39;]
        target_methods = [&#39;history&#39;,&#39;merge&#39;]
        driver_methods= [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
        assert target_method in target_methods, &#39; &#39;.join([&#34;target_method argument of reprogram_to_trap_spaces must be among&#34;,str(target_methods)])
        assert driver_method in driver_methods, &#39; &#39;.join([&#34;driver_method argument of reprogram_to_trap_spaces must be among&#34;,str(driver_methods)])
        drivers = []

        if driver_method == &#39;GRASP&#39; and GRASP_iterations is None:
            if target_method == &#39;merge&#39;:
                GRASP_iterations = len(self.unreduced_primes)**2
            if target_method == &#39;history&#39;:
                GRASP_iterations = 2*len(self.unreduced_primes)

        target_indices = self.reductions_indices_with_states(logically_fixed)

        if target_method == &#39;history&#39;:
            for target_index in target_indices:
                drivers += self.reduction_drivers(target_index,max_drivers=max_drivers,GRASP_iterations=GRASP_iterations,method=driver_method)
        elif target_method == &#39;merge&#39;:
            for target_index in target_indices:
                target_history = self.motif_reduction_dict[target_index].motif_history
                motif_merger = {k:v for d in target_history for k,v in d.items()}

                # Because we are potentially dealing with external drivers, we
                # want to make sure the external drivers do not interfere with
                # the motif&#39;s ability to drive downstream targets
                # if driver_method != &#39;internal&#39;:
                #     motif_merger.update(logically_fixed)

                if driver_method == &#39;GRASP&#39;:
                    merger_drivers = sm_doi.GRASP(motif_merger,self.unreduced_primes,GRASP_iterations)
                    if len(merger_drivers) == 0:
                        merger_drivers = [motif_merger.copy()]
                elif driver_method == &#39;minimal&#39;:
                    merger_drivers = sm_doi.minimal_drivers(motif_merger,
                        self.unreduced_primes,max_drivers=max_drivers)
                elif driver_method == &#39;internal&#39;:
                    merger_drivers = sm_doi.internal_drivers(motif_merger,
                        self.unreduced_primes,max_drivers=max_drivers)

                drivers += [x for x in merger_drivers if not x in drivers]

        drivers = sorted(drivers,key=lambda x: len(x))

        # Next, we remove redundant control sets.
        # In the minimal_history scheme, a set x is redundant if there is a y
        # that contains all control sets of x in the same order.
        # In all other schemes, x is redundant if it is a subset of some y.
        nonredundant_drivers = []
        if target_method == &#39;history&#39; and (driver_method == &#39;minimal&#39; or driver_method == &#39;GRASP&#39;):
            nonredundant_drivers = []
            for x in drivers: # drivers is sorted from fewest timesteps to most
                add_x = True
                for y in nonredundant_drivers: # note: len(y) &lt;= len(x)
                    for offset in range(len(x)-len(y)+1):
                        for i in range(len(y)):
                            # want to check that x[i+offset] is a special case of y[i]
                            for j in range(len(y)):
                                xset = set([frozenset(tuple(xdict.items())) for xdict in x[i+offset]])
                                yset = set([frozenset(tuple(xdict.items())) for xdict in y[i]])
                                if yset &lt;= xset:
                                    add_x = False
                                    break
                            if not add_x: break
                        if not add_x: break
                    if not add_x: break
                if add_x:
                    nonredundant_drivers.append(x)

        else:
            for i in range(len(drivers)):
                use_i = True
                for j in range(i): # i &gt; j
                    if drivers[i].items() &gt;= drivers[j].items():
                        use_i = False
                        break
                if use_i: nonredundant_drivers.append(drivers[i])

        return nonredundant_drivers</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pystablemotifs.succession.SuccessionDiagram.add_motif_permutation"><code class="name flex">
<span>def <span class="ident">add_motif_permutation</span></span>(<span>self, reduction_index, permutation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a permutation of a preexisting stable motif history to a precomputed
MotifReduction object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reduction_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the preexisting reduced network.</dd>
<dt><strong><code>permutation</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Permutation that maps the preexisting history to the input history.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_motif_permutation(self,reduction_index,permutation):
    &#34;&#34;&#34;Adds a permutation of a preexisting stable motif history to a precomputed
    MotifReduction object.

    Parameters
    ----------
    reduction_index : int
        Index of the preexisting reduced network.
    permutation : list of int
        Permutation that maps the preexisting history to the input history.

    &#34;&#34;&#34;
    self.motif_reduction_dict[reduction_index].merged_history_permutations.append(permutation)
    for child in nx.topological_sort(self.digraph):
        for parent in self.digraph.predecessors(child):
            for parent_perm,child_perm in it.product(
                self.motif_reduction_dict[parent].merged_history_permutations,
                self.motif_reduction_dict[child].merged_history_permutations):
                new_perm = child_perm.copy()
                for i,p in enumerate(parent_perm):
                    new_perm[i] = child_perm[p]
                if not new_perm in self.motif_reduction_dict[child].merged_history_permutations:
                    self.motif_reduction_dict[child].merged_history_permutations.append(new_perm)</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.add_motif_reduction"><code class="name flex">
<span>def <span class="ident">add_motif_reduction</span></span>(<span>self, motif_reduction)</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts a given MotifReduction into the succession diagram. Does not
check for consistency, but will insert a properly constructed MotifReduction
into the correct place in the diagram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>motif_reduction</code></strong> :&ensp;<code>MotifReduction</code></dt>
<dd>Reduced network to be appended to the succession diagram.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_motif_reduction(self,motif_reduction):
    &#34;&#34;&#34;Inserts a given MotifReduction into the succession diagram. Does not
    check for consistency, but will insert a properly constructed MotifReduction
    into the correct place in the diagram.

    Parameters
    ----------
    motif_reduction : MotifReduction
        Reduced network to be appended to the succession diagram.

    &#34;&#34;&#34;
    if self.motif_reduction_dict == {}:
        self.unreduced_primes = motif_reduction.reduced_primes

    # note: N is computed BEFORE the new reduction is added,
    # so it will be the reduction index AFTER the reduction is added.
    N = len(self.motif_reduction_dict)
    new_set = set([frozenset(tuple(x.items())) for x in motif_reduction.motif_history])
    if N == 0:
        self.digraph.add_node(0)
    else:
        for i,reduction in self.motif_reduction_dict.items():
            old_set = set([frozenset(tuple(x.items())) for x in reduction.motif_history])

            # see if we&#39;re adding a parent of an existing reduction
            if len(old_set) == len(new_set) + 1:
                diff_set = old_set - new_set
                if len(diff_set) == 1:
                    missing_motif = dict(diff_set.pop())
                    if missing_motif in motif_reduction.stable_motifs:
                        self.digraph.add_edge(N,i)
            # see if we&#39;re adding a child of an existing reduction
            elif len(old_set) == len(new_set) - 1:
                diff_set = new_set - old_set
                if len(diff_set) == 1:
                    missing_motif = dict(diff_set.pop())
                    if missing_motif in reduction.stable_motifs or len(new_set) == 1: # valid motif OR source combination
                        self.digraph.add_edge(i,N)

    self.motif_reduction_dict[N] = motif_reduction
    self.add_motif_permutation(N,list(range(len(motif_reduction.motif_history))))</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.find_equivalent_reduction"><code class="name flex">
<span>def <span class="ident">find_equivalent_reduction</span></span>(<span>self, fixed)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts the MotifReduction object that has the frozen node values
specified by fixed, if such an object exists (returns None otherwise).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fixed</code></strong> :&ensp;<code>partial state dictionary</code></dt>
<dd>Nodes values that have been fixed and reduced by stable motifs and their
logical domain of influence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MotifReduction</code></dt>
<dd>Reduced network that has the frozen node values specified by fixed,
if such an object exists (returns None otherwise).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_equivalent_reduction(self,fixed):
    &#34;&#34;&#34;Extracts the MotifReduction object that has the frozen node values
    specified by fixed, if such an object exists (returns None otherwise).

    Parameters
    ----------
    fixed : partial state dictionary
        Nodes values that have been fixed and reduced by stable motifs and their
        logical domain of influence.

    Returns
    -------
    MotifReduction
        Reduced network that has the frozen node values specified by fixed,
        if such an object exists (returns None otherwise).

    &#34;&#34;&#34;
    for reduction in self.motif_reduction_dict.values():
        if reduction.logically_fixed_nodes == fixed:
            return reduction
    return None</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.find_motif_permutation"><code class="name flex">
<span>def <span class="ident">find_motif_permutation</span></span>(<span>self, motif_history)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether some permutation of the input motif_history is already
represented in the succession diagram. If so, return the preexisting
reduction's index and the permutation that maps between the two histories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>motif_history</code></strong> :&ensp;<code>list</code> of <code>partial state dictionaries</code></dt>
<dd>Stable motifs that can lock in to give a given reduced network (in
order).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reduction_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the preexisting reduced network. This value is None if no such
reduced network exists.</dd>
<dt><strong><code>permutation</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Permutation that maps the preexisting history to the input history.
This value is None if no such history exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_motif_permutation(self,motif_history):
    &#34;&#34;&#34;Check whether some permutation of the input motif_history is already
    represented in the succession diagram. If so, return the preexisting
    reduction&#39;s index and the permutation that maps between the two histories.

    Parameters
    ----------
    motif_history : list of partial state dictionaries
        Stable motifs that can lock in to give a given reduced network (in
        order).

    Returns
    -------
    reduction_index : int
        Index of the preexisting reduced network. This value is None if no such
        reduced network exists.
    permutation : list of int
        Permutation that maps the preexisting history to the input history.
        This value is None if no such history exists.

    &#34;&#34;&#34;
    for reduction_index,mr in self.motif_reduction_dict.items():
        if len(mr.motif_history) == len(motif_history):
            if all([x in mr.motif_history for x in motif_history]):
                permutation = []
                for x in motif_history:
                    permutation.append(mr.motif_history.index(x))
                return reduction_index,permutation # We already have an equivalent motif in the list
    return None,None</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.get_motifs"><code class="name flex">
<span>def <span class="ident">get_motifs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the stable motifs of a system and its reduced networks from its
attractor repertoire. Notably, these include both the system's primary stable
motifs and conditionally stable motifs (see, e.g., Deritei et al. 2019).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>dictionaries</code></dt>
<dd>Stable motifs that appear in the system or during reduction (in no
particular order).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_motifs(self):
    &#34;&#34;&#34;Extract the stable motifs of a system and its reduced networks from its
    attractor repertoire. Notably, these include both the system&#39;s primary stable
    motifs and conditionally stable motifs (see, e.g., Deritei et al. 2019).

    Returns
    -------
    list of dictionaries
        Stable motifs that appear in the system or during reduction (in no
        particular order).

    &#34;&#34;&#34;
    SM_set = set([])
    for reduction in self.motif_reduction_dict.values():
        if len(reduction.motif_history)&gt;0:
            SM_set.add(frozenset(reduction.motif_history[-1].items()))
    return [dict(s) for s in SM_set]</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.reduction_drivers"><code class="name flex">
<span>def <span class="ident">reduction_drivers</span></span>(<span>self, target_index, method='internal', max_drivers=None, GRASP_iterations=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find control strategies that lead to the reduced network specified by
the target index. Several control strategies are implemented. See
succession.SuccessionDiagram.reprogram_to_trap_spaces for a detailed
description of control methods available. Generally, this method should
not be used directly. Instead, use reprogram_to_trap_spaces.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the target reduced network.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>One of 'internal', 'minimal', or 'GRASP'. See
succession.SuccessionDiagram.reprogram_to_trap_spaces for details.</dd>
<dt><strong><code>max_drivers</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of driver nodes to consider (not used in GRASP methods).
If none, the upper limit is given by the number of free variables
(the default is None).</dd>
<dt><strong><code>GRASP_iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of times to construct GRASP driver sets; only used in GRASP
methods. If none, the number of iterations is chosen based on the
network size (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Control strategies found; interpretation depends on method selected
See succession.SuccessionDiagram.reprogram_to_trap_spaces for details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduction_drivers(self,target_index,method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None):
    &#34;&#34;&#34;Find control strategies that lead to the reduced network specified by
    the target index. Several control strategies are implemented. See
    succession.SuccessionDiagram.reprogram_to_trap_spaces for a detailed
    description of control methods available. Generally, this method should
    not be used directly. Instead, use reprogram_to_trap_spaces.

    Parameters
    ----------
    target_index : int
        Index of the target reduced network.
    method : str
        One of &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39;. See
        succession.SuccessionDiagram.reprogram_to_trap_spaces for details.
    max_drivers : int
        Maximum number of driver nodes to consider (not used in GRASP methods).
        If none, the upper limit is given by the number of free variables
        (the default is None).
    GRASP_iterations : int
        Number of times to construct GRASP driver sets; only used in GRASP
        methods. If none, the number of iterations is chosen based on the
        network size (the default is None).

    Returns
    -------
    list
        Control strategies found; interpretation depends on method selected
        See succession.SuccessionDiagram.reprogram_to_trap_spaces for details.

    &#34;&#34;&#34;
    methods = [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
    assert method in methods, &#39; &#39;.join([&#34;method argument of reduction_drivers must be among&#34;,str(methods)])
    drivers = []
    for path in nx.all_simple_paths(self.digraph,0,target_index):
        path_motif_history=[]
        path_drivers = []
        for ind in path:
            if ind == 0:
                ind_prev = ind
                continue
            path_motif_history += [x for x in self.motif_reduction_dict[ind].motif_history if not x in path_motif_history]

            if method == &#39;internal&#39;:
                history_drivers = sm_doi.internal_drivers(path_motif_history[-1],
                    self.motif_reduction_dict[ind_prev].reduced_primes,
                    max_drivers=max_drivers)
            elif method == &#39;GRASP&#39;:
                history_drivers = sm_doi.GRASP(path_motif_history[-1],
                    self.motif_reduction_dict[ind_prev].reduced_primes,
                    GRASP_iterations = GRASP_iterations)
                if len(history_drivers) == 0:
                    history_drivers = [path_motif_history[-1]]
            elif method == &#39;minimal&#39;:
                history_drivers = sm_doi.minimal_drivers(path_motif_history[-1],
                    self.motif_reduction_dict[ind_prev].reduced_primes,
                    max_drivers=max_drivers)

            path_drivers.append(history_drivers)

            ind_prev = ind
        if method == &#39;internal&#39;:
            # merge control sets along the path
            for control_sequence in it.product(*path_drivers):
                control_set = {k:v for x in control_sequence for k,v in x.items()}
                if not control_set in drivers:
                    drivers.append(control_set)
        elif method == &#39;minimal&#39; or method == &#39;GRASP&#39;:
            drivers.append(path_drivers)
    return drivers</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.reductions_indices_with_states"><code class="name flex">
<span>def <span class="ident">reductions_indices_with_states</span></span>(<span>self, logically_fixed, optimize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find all reductions (by index) that have the nodes states specified
logically fixed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logically_fixed</code></strong> :&ensp;<code>partial state dictionary</code></dt>
<dd>Nodes states that should be fixed in all returned network reductions.</dd>
<dt><strong><code>optimize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to remove reduced networks that are subnetworks of valid
reductions. This is generally recommended so as to obtain the most
parsimonious control strategies (the default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>Indices of reduced networks that have the appropriate fixed states.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reductions_indices_with_states(self,logically_fixed,optimize=True):
    &#34;&#34;&#34;Find all reductions (by index) that have the nodes states specified
    logically fixed.

    Parameters
    ----------
    logically_fixed : partial state dictionary
        Nodes states that should be fixed in all returned network reductions.
    optimize : bool
        Whether to remove reduced networks that are subnetworks of valid
        reductions. This is generally recommended so as to obtain the most
        parsimonious control strategies (the default is True).

    Returns
    -------
    list of int
        Indices of reduced networks that have the appropriate fixed states.

    &#34;&#34;&#34;
    if not optimize:
        # NOTE: This finds all reductions, not just those closest to the root
        target_indices = []
        for i,reduction in self.motif_reduction_dict.items():
            if logically_fixed.items() &lt;= reduction.logically_fixed_nodes.items():
                target_indices.append(i)
        return target_indices
    else:
        # The unoptimized result
        target_indices_unoptimized = self.reductions_indices_with_states(logically_fixed,optimize=False)
        target_indices_all = target_indices_unoptimized.copy()

        # Add nodes that inevitably reach nodes in the unoptimized result
        nodes_to_consider = [x for x in self.digraph if (not x in target_indices_all
            and self.motif_reduction_dict[x].terminal == &#34;no&#34;)]
        for i in nodes_to_consider:
            bad_sinks = [x for x in nx.descendants(self.digraph,i) | set([i]) if (
                not self.motif_reduction_dict[x].terminal == &#34;no&#34; # is a sink and . . .
                and not x in target_indices_unoptimized)] # does not have the right nodes fixed

            if len(bad_sinks) == 0:
                target_indices_all.append(i)

        # remove nodes who have ancestors that would work instead, as those
        # will be closer to the root and easier to control
        target_indices = []
        for target_index in target_indices_all:
            if set(nx.ancestors(self.digraph,target_index)) &amp; set(target_indices_all) == set():
                target_indices.append(target_index)

        return target_indices</code></pre>
</details>
</dd>
<dt id="pystablemotifs.succession.SuccessionDiagram.reprogram_to_trap_spaces"><code class="name flex">
<span>def <span class="ident">reprogram_to_trap_spaces</span></span>(<span>self, logically_fixed, target_method='history', driver_method='internal', max_drivers=None, GRASP_iterations=None, GRASP_score_override=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find driver sets that lead to fixing the node states specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logically_fixed</code></strong> :&ensp;<code>partial state dictionary</code></dt>
<dd>Targeted fixed nodes.</dd>
<dt><strong><code>target_method</code></strong> :&ensp;<code>str</code></dt>
<dd>Either 'history' or 'merge'; see Notes below for details.</dd>
<dt><strong><code>driver_method</code></strong> :&ensp;<code>str</code></dt>
<dd>Either 'internal', 'minimal', or 'GRASP' see Notes below for details.</dd>
<dt><strong><code>max_drivers</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of driver nodes to consider (not used in GRASP methods).
If none, the upper limit is given by the number of free variables
(the default is None).</dd>
<dt><strong><code>GRASP_iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of times to construct GRASP driver sets; only used in GRASP
methods. If none, the number of iterations is chosen based on the
network size (the default is None).</dd>
<dt><strong><code>GRASP_score_override</code></strong> :&ensp;<code>function</code></dt>
<dd>Optional heuristic score function override (see drivers.GRASP
for details). Only used in GRASP methods (the default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Control strategies found; interpretation depends on method selected
See Notes below for details.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The various combinations of target_method and driver_method options result
in different control strategies, which are outlined below.</p>
<p>target_method = history, driver_method = internal:
Finds all shortest stable motif histories that result in the target node states
being logically fixed. Each stable motif is searched for internal driver nodes.
The resulting internal drivers are combined into a single
control set. The
return value consists of all such control sets for all
stable motif histories.
Each control set eventually becomes self-sustaining.</p>
<p>target_method = history, driver_method = minimal:
Similar to the history method, except the search for stable motif drivers
includes external driver nodes for the motif and does not extend to driver sets
of larger size once one driver set has been found for a motif. Because the
search includes external driver nodes, special care must be taken in interpreting
the effect of the drivers, as their influence may impact the effect of motifs
stabilizing. Thus, the control is only guaranteed to work if the interventions
are temporary and implemented in the order specified by the motif history.</p>
<p>For this reason, the output consists of lists of ordered interventions.
Each element of the return value is a list of lists of dictionaries. Each
element of the return value represents a control strategy. To implement such
a strategy, select a dictionary from the first element of the strategy and
fix the node states it specifies until their influence has propagated through
the system. Then repeat this process iteratively for each element of the strategy
list, in order. For example, if
nonredundant_drivers = [ [[{'xD':1,'xE=1'}]], [[{'xA':1},{'xB':1}],[{'xC':1}]] ]
then there are two control strategies available:
1) fix xD=xE=1 temporarily and
2) first fix either xA=1 or xB=1 temporarily, then fix xC=1 temporarily.</p>
<p>target_method = history, driver_method = GRASP:
The same as history, minimal, except external driver nodes are searched for
using the GRASP algorithm using GRASP_iterations iterations.</p>
<p>target_method = merge, driver_method = internal:
Finds all shortest stable motif histories that result in the target node states
being logically fixed. All node states in the motifs in the history are merged
into a stable module dictionary. This is then searched for internal driver
nodes. Each element of the return value is a dictionary corresponding to a
control set. Each control set eventually becomes self-sustaining.</p>
<p>target_method = merge, driver_method = minimal:
Similar to the merge method, except the search for drivers is conducted over
all nodes, not just those internal to the merged stable module. Furthermore,
the search is truncated when a control set is found such that the search does
not proceed to driver sets larger than the smallest found. Each element of
the return value is a dictionary corresponding to a control set. The control
sets are only guaranteed to result in activation of the target if they are
temporary interventions.</p>
<p>target_method = merge, driver_method = GRASP:
The same as merge, minimal, except external driver nodes are searched for
using the GRASP algorithm using GRASP_iterations iterations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reprogram_to_trap_spaces(self,logically_fixed,target_method=&#39;history&#39;,driver_method=&#39;internal&#39;,max_drivers=None,GRASP_iterations=None,GRASP_score_override=None):
    &#34;&#34;&#34;Find driver sets that lead to fixing the node states specified.

    Parameters
    ----------
    logically_fixed : partial state dictionary
        Targeted fixed nodes.
    target_method : str
        Either &#39;history&#39; or &#39;merge&#39;; see Notes below for details.
    driver_method : str
        Either &#39;internal&#39;, &#39;minimal&#39;, or &#39;GRASP&#39; see Notes below for details.
    max_drivers : int
        Maximum number of driver nodes to consider (not used in GRASP methods).
        If none, the upper limit is given by the number of free variables
        (the default is None).
    GRASP_iterations : int
        Number of times to construct GRASP driver sets; only used in GRASP
        methods. If none, the number of iterations is chosen based on the
        network size (the default is None).
    GRASP_score_override : function
        Optional heuristic score function override (see drivers.GRASP
        for details). Only used in GRASP methods (the default is None).

    Returns
    -------
    list
        Control strategies found; interpretation depends on method selected
        See Notes below for details.

    Notes
    -----
    The various combinations of target_method and driver_method options result
    in different control strategies, which are outlined below.

    target_method = history, driver_method = internal:
    Finds all shortest stable motif histories that result in the target node states
    being logically fixed. Each stable motif is searched for internal driver nodes.
    The resulting internal drivers are combined into a single  control set. The
    return value consists of all such control sets for all  stable motif histories.
    Each control set eventually becomes self-sustaining.

    target_method = history, driver_method = minimal:
    Similar to the history method, except the search for stable motif drivers
    includes external driver nodes for the motif and does not extend to driver sets
    of larger size once one driver set has been found for a motif. Because the
    search includes external driver nodes, special care must be taken in interpreting
    the effect of the drivers, as their influence may impact the effect of motifs
    stabilizing. Thus, the control is only guaranteed to work if the interventions
    are temporary and implemented in the order specified by the motif history.

    For this reason, the output consists of lists of ordered interventions.
    Each element of the return value is a list of lists of dictionaries. Each
    element of the return value represents a control strategy. To implement such
    a strategy, select a dictionary from the first element of the strategy and
    fix the node states it specifies until their influence has propagated through
    the system. Then repeat this process iteratively for each element of the strategy
    list, in order. For example, if
    nonredundant_drivers = [ [[{&#39;xD&#39;:1,&#39;xE=1&#39;}]], [[{&#39;xA&#39;:1},{&#39;xB&#39;:1}],[{&#39;xC&#39;:1}]] ]
    then there are two control strategies available:
    1) fix xD=xE=1 temporarily and
    2) first fix either xA=1 or xB=1 temporarily, then fix xC=1 temporarily.

    target_method = history, driver_method = GRASP:
    The same as history, minimal, except external driver nodes are searched for
    using the GRASP algorithm using GRASP_iterations iterations.

    target_method = merge, driver_method = internal:
    Finds all shortest stable motif histories that result in the target node states
    being logically fixed. All node states in the motifs in the history are merged
    into a stable module dictionary. This is then searched for internal driver
    nodes. Each element of the return value is a dictionary corresponding to a
    control set. Each control set eventually becomes self-sustaining.

    target_method = merge, driver_method = minimal:
    Similar to the merge method, except the search for drivers is conducted over
    all nodes, not just those internal to the merged stable module. Furthermore,
    the search is truncated when a control set is found such that the search does
    not proceed to driver sets larger than the smallest found. Each element of
    the return value is a dictionary corresponding to a control set. The control
    sets are only guaranteed to result in activation of the target if they are
    temporary interventions.

    target_method = merge, driver_method = GRASP:
    The same as merge, minimal, except external driver nodes are searched for
    using the GRASP algorithm using GRASP_iterations iterations.

    &#34;&#34;&#34;

    #methods = [&#39;history&#39;,&#39;merge&#39;,&#39;minimal_history&#39;,&#39;minimal_merge&#39;]
    target_methods = [&#39;history&#39;,&#39;merge&#39;]
    driver_methods= [&#39;internal&#39;,&#39;minimal&#39;,&#39;GRASP&#39;]
    assert target_method in target_methods, &#39; &#39;.join([&#34;target_method argument of reprogram_to_trap_spaces must be among&#34;,str(target_methods)])
    assert driver_method in driver_methods, &#39; &#39;.join([&#34;driver_method argument of reprogram_to_trap_spaces must be among&#34;,str(driver_methods)])
    drivers = []

    if driver_method == &#39;GRASP&#39; and GRASP_iterations is None:
        if target_method == &#39;merge&#39;:
            GRASP_iterations = len(self.unreduced_primes)**2
        if target_method == &#39;history&#39;:
            GRASP_iterations = 2*len(self.unreduced_primes)

    target_indices = self.reductions_indices_with_states(logically_fixed)

    if target_method == &#39;history&#39;:
        for target_index in target_indices:
            drivers += self.reduction_drivers(target_index,max_drivers=max_drivers,GRASP_iterations=GRASP_iterations,method=driver_method)
    elif target_method == &#39;merge&#39;:
        for target_index in target_indices:
            target_history = self.motif_reduction_dict[target_index].motif_history
            motif_merger = {k:v for d in target_history for k,v in d.items()}

            # Because we are potentially dealing with external drivers, we
            # want to make sure the external drivers do not interfere with
            # the motif&#39;s ability to drive downstream targets
            # if driver_method != &#39;internal&#39;:
            #     motif_merger.update(logically_fixed)

            if driver_method == &#39;GRASP&#39;:
                merger_drivers = sm_doi.GRASP(motif_merger,self.unreduced_primes,GRASP_iterations)
                if len(merger_drivers) == 0:
                    merger_drivers = [motif_merger.copy()]
            elif driver_method == &#39;minimal&#39;:
                merger_drivers = sm_doi.minimal_drivers(motif_merger,
                    self.unreduced_primes,max_drivers=max_drivers)
            elif driver_method == &#39;internal&#39;:
                merger_drivers = sm_doi.internal_drivers(motif_merger,
                    self.unreduced_primes,max_drivers=max_drivers)

            drivers += [x for x in merger_drivers if not x in drivers]

    drivers = sorted(drivers,key=lambda x: len(x))

    # Next, we remove redundant control sets.
    # In the minimal_history scheme, a set x is redundant if there is a y
    # that contains all control sets of x in the same order.
    # In all other schemes, x is redundant if it is a subset of some y.
    nonredundant_drivers = []
    if target_method == &#39;history&#39; and (driver_method == &#39;minimal&#39; or driver_method == &#39;GRASP&#39;):
        nonredundant_drivers = []
        for x in drivers: # drivers is sorted from fewest timesteps to most
            add_x = True
            for y in nonredundant_drivers: # note: len(y) &lt;= len(x)
                for offset in range(len(x)-len(y)+1):
                    for i in range(len(y)):
                        # want to check that x[i+offset] is a special case of y[i]
                        for j in range(len(y)):
                            xset = set([frozenset(tuple(xdict.items())) for xdict in x[i+offset]])
                            yset = set([frozenset(tuple(xdict.items())) for xdict in y[i]])
                            if yset &lt;= xset:
                                add_x = False
                                break
                        if not add_x: break
                    if not add_x: break
                if not add_x: break
            if add_x:
                nonredundant_drivers.append(x)

    else:
        for i in range(len(drivers)):
            use_i = True
            for j in range(i): # i &gt; j
                if drivers[i].items() &gt;= drivers[j].items():
                    use_i = False
                    break
            if use_i: nonredundant_drivers.append(drivers[i])

    return nonredundant_drivers</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pystablemotifs" href="index.html">pystablemotifs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pystablemotifs.succession.build_succession_diagram" href="#pystablemotifs.succession.build_succession_diagram">build_succession_diagram</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pystablemotifs.succession.SuccessionDiagram" href="#pystablemotifs.succession.SuccessionDiagram">SuccessionDiagram</a></code></h4>
<ul class="">
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.add_motif_permutation" href="#pystablemotifs.succession.SuccessionDiagram.add_motif_permutation">add_motif_permutation</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.add_motif_reduction" href="#pystablemotifs.succession.SuccessionDiagram.add_motif_reduction">add_motif_reduction</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.find_equivalent_reduction" href="#pystablemotifs.succession.SuccessionDiagram.find_equivalent_reduction">find_equivalent_reduction</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.find_motif_permutation" href="#pystablemotifs.succession.SuccessionDiagram.find_motif_permutation">find_motif_permutation</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.get_motifs" href="#pystablemotifs.succession.SuccessionDiagram.get_motifs">get_motifs</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.reduction_drivers" href="#pystablemotifs.succession.SuccessionDiagram.reduction_drivers">reduction_drivers</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.reductions_indices_with_states" href="#pystablemotifs.succession.SuccessionDiagram.reductions_indices_with_states">reductions_indices_with_states</a></code></li>
<li><code><a title="pystablemotifs.succession.SuccessionDiagram.reprogram_to_trap_spaces" href="#pystablemotifs.succession.SuccessionDiagram.reprogram_to_trap_spaces">reprogram_to_trap_spaces</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>