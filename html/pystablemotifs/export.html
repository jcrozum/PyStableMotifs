<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pystablemotifs.export API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pystablemotifs.export</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pystablemotifs as sm
import networkx as nx

def _format_reduction_label(s):
    &#34;&#34;&#34;Helper function to make graph labels more readable. Removes single quotes
    and square brackets from the input string.

    Parameters
    ----------
    s : str
        Input label.

    Returns
    -------
    str
        Label with characters &#39;, [, and ] removed.

    &#34;&#34;&#34;
    return s.replace(&#34;&#39;&#34;,&#34;&#34;).replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;)

def expanded_network(primes, single_parent_composites = False):
    &#34;&#34;&#34;Produce the expanded network for given input update rules.

    Parameters
    ----------
    primes : pyboolnet primes dictionary
        The update rules for which to construct the expanded network.
    single_parent_composites : bool
        Whether to insert composite nodes between virtual nodes when one is a prime
        implicant of the other. If False, the number of nodes is decreased; if
        True, then the expanded network is bipartite (the default is False).

    Returns
    -------
    networkx.DiGraph
        Digraph representing the expanded network. Nodes have a &#39;type&#39; attribute
        that can be either &#39;virtual&#39; or &#39;composite&#39;.

    &#34;&#34;&#34;
    G = nx.DiGraph()
    cnode_id = 0
    for p in primes:
        for v in [0,1]:
            name = &#39;(&#39;+str(p)+&#39;,&#39;+str(v)+&#39;)&#39;
            G.add_node(name)
            G.nodes[name][&#39;label&#39;] = name
            G.nodes[name][&#39;type&#39;] = &#39;virtual&#39;

            for hedge in primes[p][v]:
                G.add_node(cnode_id)
                G.nodes[cnode_id][&#39;type&#39;] = &#39;composite&#39;
                G.add_edge(cnode_id,name)

                for k in hedge:
                    parent = &#39;(&#39; + str(k) + &#39;,&#39; + str(hedge[k]) + &#39;)&#39;
                    G.add_edge(parent,cnode_id)
                cnode_id += 1

    # If we want to remove composite nodes of &#34;size&#34; one
    if not single_parent_composites:
        for i in range(cnode_id):
            if G.in_degree(i) == 1:
                pre = list(G.predecessors(i))[0]
                suc = G.successors(i)
                for j in suc:
                    G.add_edge(pre,j)
                G.remove_node(i)


    return G

def networkx_succession_diagram(ar,include_attractors_in_diagram=True,use_compressed_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Rozum et al. (2021). This is an
    alias for the function export.networkx_succession_diagram_reduced_network_based.

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).
    use_compressed_diagram : bool
        Whether to use the (potentially compressed) succession diagram stored in
        ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
        These are equivelent unless ar.simplify_diagram is called. See
        AttractorRepertoire.py for additional details. The default is True.

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;
    return networkx_succession_diagram_reduced_network_based(ar,
        include_attractors_in_diagram=include_attractors_in_diagram,
        use_compressed_diagram=use_compressed_diagram)

def networkx_succession_diagram_reduced_network_based(ar,include_attractors_in_diagram=True,use_compressed_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Rozum et al. (2021).

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).
    use_compressed_diagram : bool
        Whether to use the (potentially compressed) succession diagram stored in
        ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
        These are equivelent unless ar.simplify_diagram is called. See
        AttractorRepertoire.py for additional details. The default is True.

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;

    if use_compressed_diagram:
        G_reduced_network_based=ar.succession_digraph.copy()
        relevant_nodes = ar.relevant_nodes
    else:
        G_reduced_network_based=ar.succession_diagram.digraph.copy()
        relevant_nodes = ar.primes.keys()

    has_nodes = False
    for i in G_reduced_network_based.nodes():
        has_nodes = True
        states={}
        for k,v in ar.succession_diagram.motif_reduction_dict[i].logically_fixed_nodes.items():
            if k in relevant_nodes:
                states[k]=v
        G_reduced_network_based.nodes[i][&#39;index&#39;] = i
        G_reduced_network_based.nodes[i][&#39;states&#39;]=states

        contraction_indices = [i]
        if use_compressed_diagram and &#39;contraction&#39; in ar.succession_digraph.nodes[i].keys():
            contraction_indices += list(ar.succession_digraph.nodes[i][&#39;contraction&#39;].keys())

        histories = []
        for c in contraction_indices:
            histories.append(ar.succession_diagram.motif_reduction_dict[c].motif_history)
        G_reduced_network_based.nodes[i][&#39;history&#39;]=histories
        G_reduced_network_based.nodes[i][&#39;motif union&#39;] = {k:v for h in histories
            for m in h
            for k,v in m.items()
            if k in ar.relevant_nodes or not use_compressed_diagram}

    if not has_nodes:
        G_reduced_network_based.add_node(0)
        G_reduced_network_based.nodes[0][&#39;index&#39;] = 0
        G_reduced_network_based.nodes[0][&#39;states&#39;] = {}
        G_reduced_network_based.nodes[0][&#39;history&#39;] = [[]]
        G_reduced_network_based.nodes[0][&#39;motif union&#39;] = {}

    for u,v in G_reduced_network_based.edges():
        ufixed = G_reduced_network_based.nodes[u][&#39;states&#39;]
        vfixed = G_reduced_network_based.nodes[v][&#39;states&#39;]
        lock_in = {}
        for k,val in vfixed.items():
            if k not in ufixed.keys():
                lock_in[k] = val
        G_reduced_network_based.edges[u,v][&#39;states&#39;] = lock_in

        ufixed = G_reduced_network_based.nodes[u][&#39;motif union&#39;]
        vfixed = G_reduced_network_based.nodes[v][&#39;motif union&#39;]
        lock_in = {}
        for k,val in vfixed.items():
            if k not in ufixed.keys():
                lock_in[k] = val
        G_reduced_network_based.edges[u,v][&#39;motif&#39;] = lock_in

    if include_attractors_in_diagram and not use_compressed_diagram:
        for a_index,a in enumerate(ar.attractors):
            astr = &#39;A&#39;+str(a_index)
            G_reduced_network_based.add_node(astr)
            G_reduced_network_based.nodes[astr][&#39;index&#39;]=astr
            G_reduced_network_based.nodes[astr][&#39;states&#39;]=a.attractor_dict

            for r in a.reductions:
                r_ind = list(ar.succession_diagram.motif_reduction_dict.values()).index(r)
                r_key=list(ar.succession_diagram.motif_reduction_dict.keys())[r_ind]
                if r_key in G_reduced_network_based.nodes():
                    G_reduced_network_based.add_edge(r_key,astr,states=&#39;&#39;)
    if include_attractors_in_diagram and use_compressed_diagram:
        for a_index,a in enumerate(ar.attractor_equivalence_classes):
            astr = &#39;A&#39;+str(a_index)
            G_reduced_network_based.add_node(astr)
            G_reduced_network_based.nodes[astr][&#39;index&#39;]=astr
            G_reduced_network_based.nodes[astr][&#39;states&#39;]=a[&#39;states&#39;]

            for r_key in a[&#39;reductions&#39;]:
                if r_key in G_reduced_network_based.nodes():
                    G_reduced_network_based.add_edge(r_key,astr,states=&#39;&#39;)

    for n in G_reduced_network_based.nodes():
        if str(n)[0]==&#39;A&#39;:
            G_reduced_network_based.nodes[n][&#39;label&#39;]=&#39;Attractor &#39; +\
                G_reduced_network_based.nodes[n][&#39;index&#39;] +\
                &#39;:\n &#39;+str(G_reduced_network_based.nodes[n][&#39;states&#39;])
        else:
            G_reduced_network_based.nodes[n][&#39;label&#39;]=str(G_reduced_network_based.nodes[n][&#39;motif union&#39;])

    return G_reduced_network_based

def networkx_succession_diagram_motif_based(ar,include_attractors_in_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Zanudo and Albert (2015). If
    attractors are not included, this is the line graph of the succession diagram
    defined in Rozum et al. (2021). Does not support compression.

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;
    G_reduced_network_based = networkx_succession_diagram_reduced_network_based(ar,
        include_attractors_in_diagram=False,
        use_compressed_diagram=False)

    G_motif_based = nx.line_graph(G_reduced_network_based)

    for e in G_reduced_network_based.edges():
        G_motif_based.nodes[e][&#39;states&#39;] = G_reduced_network_based.edges[e][&#39;states&#39;]
        G_motif_based.nodes[e][&#39;motif&#39;] = G_reduced_network_based.edges[e][&#39;motif&#39;]
        G_motif_based.nodes[e][&#39;label&#39;] = str(G_reduced_network_based.edges[e][&#39;motif&#39;])
    for e in G_motif_based.edges():
        G_motif_based.edges[e][&#39;states&#39;]=&#39;&#39;


    if include_attractors_in_diagram:
        for a_index,a in enumerate(ar.attractors):
            astr = &#39;A&#39;+str(a_index)
            G_motif_based.add_node(astr)
            G_motif_based.nodes[astr][&#39;states&#39;]=a.attractor_dict
            G_motif_based.nodes[astr][&#39;label&#39;]=&#39;Attractor &#39; + astr +\
                &#39;:\n &#39;+ str(a.attractor_dict)
            for r in a.reductions:
                r_ind = list(ar.succession_diagram.motif_reduction_dict.values()).index(r)
                r_key=list(ar.succession_diagram.motif_reduction_dict.keys())[r_ind]
                for n in G_motif_based.nodes():
                    if type(n)==tuple:
                        i,j=n
                        if r_key==j:
                            G_motif_based.add_edge((i,j),astr,states=&#39;&#39;)
    return G_motif_based

def plot_nx_succession_diagram(G, pos=None, fig_dimensions=(None,None), nx_node_kwargs=None, nx_edge_kwargs=None,
    draw_node_labels=True, labeling_convention=&#39;label&#39;, draw_edge_labels=False, nx_node_label_kwargs=None, nx_edge_label_kwargs=None):
    &#34;&#34;&#34;Plot the input succession diagram. Requires matplotlib. For finer control
    over plot appearance, it is recommended to plot g directly.

    Parameters
    ----------
    G : networkx.DiGraph
        Labeled succession diagram, e.g., as is output from
        export.networkx_succession_diagram_reduced_network_based().
    fig_dimensions : (int,int)
        Dimensions of the output figure. If (None,None), then the dimensions are
        calculated based on the number of nodes in g (the default is (None,None)).
    pos : str or graphviz_layout
        Layout for the nodes; A dictionary with nodes as keys and positions as
        values. Positions should be sequences of length 2. If none, we attempt to
        use pydot/graphviz to construct a layout, otherwise we fall back to the
        networkx planar_layout function (succession diagrams are always planar).
    draw_node_labels : bool
        Whether node labels should be drawn (True) or left as metadata (False)
        (the default is True).
    draw_edge_labels : bool
        Whether edge labels should be drawn (True) or left as metadata (False);
        only affects reduced-network-based (default) succession diagrams, not
        motif-based succession diagrams. (The default value is False.)
    labeling_convention : str
        Whether edge labels should be just the stable motifs (&#39;label&#39;) or all stabilized states (&#39;states&#39;)
        (the default is &#39;label&#39;).
    nx_node_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_nodes (in addition to G and pos).
        If None, we pass {&#39;node_size&#39;:50*G.number_of_nodes()} by default.
    nx_edge_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_edges (in addition to G and pos).
        If None, we pass {&#39;arrowstyle&#39;:&#39;-|&gt;&#39;,&#39;width&#39;:2,&#39;arrowsize&#39;:30} by default.
    nx_node_label_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_labels (in addition to G and pos).
        If None, we pass {&#39;font_size&#39;:16} by default.
    nx_edge_label_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_edge_labels (in addition to G and pos).
        If None, we pass {&#39;font_size&#39;:16} by default.

    &#34;&#34;&#34;
    import matplotlib.pyplot as plt

    if fig_dimensions == (None,None):
        fig_dimensions=(2*(G.number_of_nodes()+2),G.number_of_nodes()+2)

    if pos is None:
        try:
            from networkx.drawing.nx_agraph import graphviz_layout
            pos = graphviz_layout(G, prog=&#39;dot&#39;)
        except ImportError:
            pos = nx.planar_layout(G)

    plt.figure(figsize=fig_dimensions)

    if nx_node_kwargs is None:
        nx_node_kwargs = {&#39;node_size&#39;:50*G.number_of_nodes()}
    if nx_edge_kwargs is None:
        nx_edge_kwargs = {&#39;arrowstyle&#39;:&#39;-|&gt;&#39;,&#39;width&#39;:2,&#39;arrowsize&#39;:30}
    if nx_node_label_kwargs is None:
        nx_node_label_kwargs = {&#39;font_size&#39;:16}
    if nx_edge_label_kwargs is None:
        nx_edge_label_kwargs = {&#39;font_size&#39;:16}

    nx.drawing.draw_networkx_nodes(G, pos,**nx_node_kwargs)
    nx.draw_networkx_edges(G, pos,**nx_edge_kwargs)
    if draw_node_labels:
        if labeling_convention==&#39;label&#39;:
            nx.drawing.draw_networkx_labels(G,pos, labels=dict(G.nodes(&#39;label&#39;)),**nx_node_label_kwargs)
        else:
            nx.drawing.draw_networkx_labels(G,pos, labels=dict(G.nodes(&#39;states&#39;)),**nx_node_label_kwargs)
    if draw_edge_labels:
        nx.drawing.draw_networkx_edge_labels(G,pos,edge_labels=nx.get_edge_attributes(G,&#39;motif&#39;),**nx_edge_label_kwargs)
    plt.axis(&#39;off&#39;)
    plt.show()

def attractor_dataframe(ar):
    &#34;&#34;&#34;Summarize the input attractor repertoire in a pandas DataFrame (requires
    pandas).

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire to summarize.

    Returns
    -------
    pandas.DataFrame
        Summary of the attractors.

    &#34;&#34;&#34;
    import pandas as pd
    df=pd.DataFrame()
    for a in ar.attractors:
        df=pd.concat([df,pd.DataFrame(a.attractor_dict.values()).T],
                    ignore_index=True,axis=0,join=&#39;outer&#39;
                    ).astype(int, errors=&#39;ignore&#39;).astype(str)
    df.columns=a.attractor_dict.keys()

    return df

def save_to_graphml(G,model_name):
    &#34;&#34;&#34;Export a labeled succesion diagram to graphml format.

    Parameters
    ----------
    G : networkx.DiGraph
        Labeled succession diagram to export.
    model_name : str
        Name of file to save to (.graphml extension will be appended).

    &#34;&#34;&#34;

    #Graphml does not support complex attribues so we create a copy and stringify everything
    G_ex=G.copy()
    for n in G_ex.nodes():
        for k,v in G_ex.nodes[n].items():
            G_ex.nodes[n][k]=str(v)
    for e in G_ex.edges():
        for k,v in G_ex.edges[e].items():
            G_ex.edges[e][k]=str(v)
    nx.write_graphml(G_ex, &#34;%s.graphml&#34;%model_name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pystablemotifs.export.attractor_dataframe"><code class="name flex">
<span>def <span class="ident">attractor_dataframe</span></span>(<span>ar)</span>
</code></dt>
<dd>
<div class="desc"><p>Summarize the input attractor repertoire in a pandas DataFrame (requires
pandas).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ar</code></strong> :&ensp;<code>AttractorRepertoire</code></dt>
<dd>Attractor repertoire to summarize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>Summary of the attractors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attractor_dataframe(ar):
    &#34;&#34;&#34;Summarize the input attractor repertoire in a pandas DataFrame (requires
    pandas).

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire to summarize.

    Returns
    -------
    pandas.DataFrame
        Summary of the attractors.

    &#34;&#34;&#34;
    import pandas as pd
    df=pd.DataFrame()
    for a in ar.attractors:
        df=pd.concat([df,pd.DataFrame(a.attractor_dict.values()).T],
                    ignore_index=True,axis=0,join=&#39;outer&#39;
                    ).astype(int, errors=&#39;ignore&#39;).astype(str)
    df.columns=a.attractor_dict.keys()

    return df</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.expanded_network"><code class="name flex">
<span>def <span class="ident">expanded_network</span></span>(<span>primes, single_parent_composites=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the expanded network for given input update rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>primes</code></strong> :&ensp;<code>pyboolnet primes dictionary</code></dt>
<dd>The update rules for which to construct the expanded network.</dd>
<dt><strong><code>single_parent_composites</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to insert composite nodes between virtual nodes when one is a prime
implicant of the other. If False, the number of nodes is decreased; if
True, then the expanded network is bipartite (the default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.DiGraph</code></dt>
<dd>Digraph representing the expanded network. Nodes have a 'type' attribute
that can be either 'virtual' or 'composite'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expanded_network(primes, single_parent_composites = False):
    &#34;&#34;&#34;Produce the expanded network for given input update rules.

    Parameters
    ----------
    primes : pyboolnet primes dictionary
        The update rules for which to construct the expanded network.
    single_parent_composites : bool
        Whether to insert composite nodes between virtual nodes when one is a prime
        implicant of the other. If False, the number of nodes is decreased; if
        True, then the expanded network is bipartite (the default is False).

    Returns
    -------
    networkx.DiGraph
        Digraph representing the expanded network. Nodes have a &#39;type&#39; attribute
        that can be either &#39;virtual&#39; or &#39;composite&#39;.

    &#34;&#34;&#34;
    G = nx.DiGraph()
    cnode_id = 0
    for p in primes:
        for v in [0,1]:
            name = &#39;(&#39;+str(p)+&#39;,&#39;+str(v)+&#39;)&#39;
            G.add_node(name)
            G.nodes[name][&#39;label&#39;] = name
            G.nodes[name][&#39;type&#39;] = &#39;virtual&#39;

            for hedge in primes[p][v]:
                G.add_node(cnode_id)
                G.nodes[cnode_id][&#39;type&#39;] = &#39;composite&#39;
                G.add_edge(cnode_id,name)

                for k in hedge:
                    parent = &#39;(&#39; + str(k) + &#39;,&#39; + str(hedge[k]) + &#39;)&#39;
                    G.add_edge(parent,cnode_id)
                cnode_id += 1

    # If we want to remove composite nodes of &#34;size&#34; one
    if not single_parent_composites:
        for i in range(cnode_id):
            if G.in_degree(i) == 1:
                pre = list(G.predecessors(i))[0]
                suc = G.successors(i)
                for j in suc:
                    G.add_edge(pre,j)
                G.remove_node(i)


    return G</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.networkx_succession_diagram"><code class="name flex">
<span>def <span class="ident">networkx_succession_diagram</span></span>(<span>ar, include_attractors_in_diagram=True, use_compressed_diagram=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Label the succesion diagram and (optionally) attractors of the input attractor
repertoire according to the conventions of Rozum et al. (2021). This is an
alias for the function export.networkx_succession_diagram_reduced_network_based.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ar</code></strong> :&ensp;<code>AttractorRepertoire</code></dt>
<dd>Attractor repertoire object for which to build the diagram.</dd>
<dt><strong><code>include_attractors_in_diagram</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether attractors should be represented as nodes in the diagram (the
default is True).</dd>
<dt><strong><code>use_compressed_diagram</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to use the (potentially compressed) succession diagram stored in
ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
These are equivelent unless ar.simplify_diagram is called. See
AttractorRepertoire.py for additional details. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.DiGraph</code></dt>
<dd>A labeled digraph that represents the succession diagram.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def networkx_succession_diagram(ar,include_attractors_in_diagram=True,use_compressed_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Rozum et al. (2021). This is an
    alias for the function export.networkx_succession_diagram_reduced_network_based.

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).
    use_compressed_diagram : bool
        Whether to use the (potentially compressed) succession diagram stored in
        ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
        These are equivelent unless ar.simplify_diagram is called. See
        AttractorRepertoire.py for additional details. The default is True.

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;
    return networkx_succession_diagram_reduced_network_based(ar,
        include_attractors_in_diagram=include_attractors_in_diagram,
        use_compressed_diagram=use_compressed_diagram)</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.networkx_succession_diagram_motif_based"><code class="name flex">
<span>def <span class="ident">networkx_succession_diagram_motif_based</span></span>(<span>ar, include_attractors_in_diagram=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Label the succesion diagram and (optionally) attractors of the input attractor
repertoire according to the conventions of Zanudo and Albert (2015). If
attractors are not included, this is the line graph of the succession diagram
defined in Rozum et al. (2021). Does not support compression.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ar</code></strong> :&ensp;<code>AttractorRepertoire</code></dt>
<dd>Attractor repertoire object for which to build the diagram.</dd>
<dt><strong><code>include_attractors_in_diagram</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether attractors should be represented as nodes in the diagram (the
default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.DiGraph</code></dt>
<dd>A labeled digraph that represents the succession diagram.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def networkx_succession_diagram_motif_based(ar,include_attractors_in_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Zanudo and Albert (2015). If
    attractors are not included, this is the line graph of the succession diagram
    defined in Rozum et al. (2021). Does not support compression.

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;
    G_reduced_network_based = networkx_succession_diagram_reduced_network_based(ar,
        include_attractors_in_diagram=False,
        use_compressed_diagram=False)

    G_motif_based = nx.line_graph(G_reduced_network_based)

    for e in G_reduced_network_based.edges():
        G_motif_based.nodes[e][&#39;states&#39;] = G_reduced_network_based.edges[e][&#39;states&#39;]
        G_motif_based.nodes[e][&#39;motif&#39;] = G_reduced_network_based.edges[e][&#39;motif&#39;]
        G_motif_based.nodes[e][&#39;label&#39;] = str(G_reduced_network_based.edges[e][&#39;motif&#39;])
    for e in G_motif_based.edges():
        G_motif_based.edges[e][&#39;states&#39;]=&#39;&#39;


    if include_attractors_in_diagram:
        for a_index,a in enumerate(ar.attractors):
            astr = &#39;A&#39;+str(a_index)
            G_motif_based.add_node(astr)
            G_motif_based.nodes[astr][&#39;states&#39;]=a.attractor_dict
            G_motif_based.nodes[astr][&#39;label&#39;]=&#39;Attractor &#39; + astr +\
                &#39;:\n &#39;+ str(a.attractor_dict)
            for r in a.reductions:
                r_ind = list(ar.succession_diagram.motif_reduction_dict.values()).index(r)
                r_key=list(ar.succession_diagram.motif_reduction_dict.keys())[r_ind]
                for n in G_motif_based.nodes():
                    if type(n)==tuple:
                        i,j=n
                        if r_key==j:
                            G_motif_based.add_edge((i,j),astr,states=&#39;&#39;)
    return G_motif_based</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.networkx_succession_diagram_reduced_network_based"><code class="name flex">
<span>def <span class="ident">networkx_succession_diagram_reduced_network_based</span></span>(<span>ar, include_attractors_in_diagram=True, use_compressed_diagram=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Label the succesion diagram and (optionally) attractors of the input attractor
repertoire according to the conventions of Rozum et al. (2021).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ar</code></strong> :&ensp;<code>AttractorRepertoire</code></dt>
<dd>Attractor repertoire object for which to build the diagram.</dd>
<dt><strong><code>include_attractors_in_diagram</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether attractors should be represented as nodes in the diagram (the
default is True).</dd>
<dt><strong><code>use_compressed_diagram</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to use the (potentially compressed) succession diagram stored in
ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
These are equivelent unless ar.simplify_diagram is called. See
AttractorRepertoire.py for additional details. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.DiGraph</code></dt>
<dd>A labeled digraph that represents the succession diagram.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def networkx_succession_diagram_reduced_network_based(ar,include_attractors_in_diagram=True,use_compressed_diagram=True):
    &#34;&#34;&#34;Label the succesion diagram and (optionally) attractors of the input attractor
    repertoire according to the conventions of Rozum et al. (2021).

    Parameters
    ----------
    ar : AttractorRepertoire
        Attractor repertoire object for which to build the diagram.
    include_attractors_in_diagram : bool
        Whether attractors should be represented as nodes in the diagram (the
        default is True).
    use_compressed_diagram : bool
        Whether to use the (potentially compressed) succession diagram stored in
        ar.succession_digraph instead of the complete one ar.succession_diagram.digraph.
        These are equivelent unless ar.simplify_diagram is called. See
        AttractorRepertoire.py for additional details. The default is True.

    Returns
    -------
    networkx.DiGraph
        A labeled digraph that represents the succession diagram.

    &#34;&#34;&#34;

    if use_compressed_diagram:
        G_reduced_network_based=ar.succession_digraph.copy()
        relevant_nodes = ar.relevant_nodes
    else:
        G_reduced_network_based=ar.succession_diagram.digraph.copy()
        relevant_nodes = ar.primes.keys()

    has_nodes = False
    for i in G_reduced_network_based.nodes():
        has_nodes = True
        states={}
        for k,v in ar.succession_diagram.motif_reduction_dict[i].logically_fixed_nodes.items():
            if k in relevant_nodes:
                states[k]=v
        G_reduced_network_based.nodes[i][&#39;index&#39;] = i
        G_reduced_network_based.nodes[i][&#39;states&#39;]=states

        contraction_indices = [i]
        if use_compressed_diagram and &#39;contraction&#39; in ar.succession_digraph.nodes[i].keys():
            contraction_indices += list(ar.succession_digraph.nodes[i][&#39;contraction&#39;].keys())

        histories = []
        for c in contraction_indices:
            histories.append(ar.succession_diagram.motif_reduction_dict[c].motif_history)
        G_reduced_network_based.nodes[i][&#39;history&#39;]=histories
        G_reduced_network_based.nodes[i][&#39;motif union&#39;] = {k:v for h in histories
            for m in h
            for k,v in m.items()
            if k in ar.relevant_nodes or not use_compressed_diagram}

    if not has_nodes:
        G_reduced_network_based.add_node(0)
        G_reduced_network_based.nodes[0][&#39;index&#39;] = 0
        G_reduced_network_based.nodes[0][&#39;states&#39;] = {}
        G_reduced_network_based.nodes[0][&#39;history&#39;] = [[]]
        G_reduced_network_based.nodes[0][&#39;motif union&#39;] = {}

    for u,v in G_reduced_network_based.edges():
        ufixed = G_reduced_network_based.nodes[u][&#39;states&#39;]
        vfixed = G_reduced_network_based.nodes[v][&#39;states&#39;]
        lock_in = {}
        for k,val in vfixed.items():
            if k not in ufixed.keys():
                lock_in[k] = val
        G_reduced_network_based.edges[u,v][&#39;states&#39;] = lock_in

        ufixed = G_reduced_network_based.nodes[u][&#39;motif union&#39;]
        vfixed = G_reduced_network_based.nodes[v][&#39;motif union&#39;]
        lock_in = {}
        for k,val in vfixed.items():
            if k not in ufixed.keys():
                lock_in[k] = val
        G_reduced_network_based.edges[u,v][&#39;motif&#39;] = lock_in

    if include_attractors_in_diagram and not use_compressed_diagram:
        for a_index,a in enumerate(ar.attractors):
            astr = &#39;A&#39;+str(a_index)
            G_reduced_network_based.add_node(astr)
            G_reduced_network_based.nodes[astr][&#39;index&#39;]=astr
            G_reduced_network_based.nodes[astr][&#39;states&#39;]=a.attractor_dict

            for r in a.reductions:
                r_ind = list(ar.succession_diagram.motif_reduction_dict.values()).index(r)
                r_key=list(ar.succession_diagram.motif_reduction_dict.keys())[r_ind]
                if r_key in G_reduced_network_based.nodes():
                    G_reduced_network_based.add_edge(r_key,astr,states=&#39;&#39;)
    if include_attractors_in_diagram and use_compressed_diagram:
        for a_index,a in enumerate(ar.attractor_equivalence_classes):
            astr = &#39;A&#39;+str(a_index)
            G_reduced_network_based.add_node(astr)
            G_reduced_network_based.nodes[astr][&#39;index&#39;]=astr
            G_reduced_network_based.nodes[astr][&#39;states&#39;]=a[&#39;states&#39;]

            for r_key in a[&#39;reductions&#39;]:
                if r_key in G_reduced_network_based.nodes():
                    G_reduced_network_based.add_edge(r_key,astr,states=&#39;&#39;)

    for n in G_reduced_network_based.nodes():
        if str(n)[0]==&#39;A&#39;:
            G_reduced_network_based.nodes[n][&#39;label&#39;]=&#39;Attractor &#39; +\
                G_reduced_network_based.nodes[n][&#39;index&#39;] +\
                &#39;:\n &#39;+str(G_reduced_network_based.nodes[n][&#39;states&#39;])
        else:
            G_reduced_network_based.nodes[n][&#39;label&#39;]=str(G_reduced_network_based.nodes[n][&#39;motif union&#39;])

    return G_reduced_network_based</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.plot_nx_succession_diagram"><code class="name flex">
<span>def <span class="ident">plot_nx_succession_diagram</span></span>(<span>G, pos=None, fig_dimensions=(None, None), nx_node_kwargs=None, nx_edge_kwargs=None, draw_node_labels=True, labeling_convention='label', draw_edge_labels=False, nx_node_label_kwargs=None, nx_edge_label_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the input succession diagram. Requires matplotlib. For finer control
over plot appearance, it is recommended to plot g directly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>Labeled succession diagram, e.g., as is output from
export.networkx_succession_diagram_reduced_network_based().</dd>
<dt><strong><code>fig_dimensions</code></strong> :&ensp;<code>(int,int)</code></dt>
<dd>Dimensions of the output figure. If (None,None), then the dimensions are
calculated based on the number of nodes in g (the default is (None,None)).</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>str</code> or <code>graphviz_layout</code></dt>
<dd>Layout for the nodes; A dictionary with nodes as keys and positions as
values. Positions should be sequences of length 2. If none, we attempt to
use pydot/graphviz to construct a layout, otherwise we fall back to the
networkx planar_layout function (succession diagrams are always planar).</dd>
<dt><strong><code>draw_node_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether node labels should be drawn (True) or left as metadata (False)
(the default is True).</dd>
<dt><strong><code>draw_edge_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether edge labels should be drawn (True) or left as metadata (False);
only affects reduced-network-based (default) succession diagrams, not
motif-based succession diagrams. (The default value is False.)</dd>
<dt><strong><code>labeling_convention</code></strong> :&ensp;<code>str</code></dt>
<dd>Whether edge labels should be just the stable motifs ('label') or all stabilized states ('states')
(the default is 'label').</dd>
<dt><strong><code>nx_node_kwargs</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Keword arguments passed to nx.draw_networkx_nodes (in addition to G and pos).
If None, we pass {'node_size':50*G.number_of_nodes()} by default.</dd>
<dt><strong><code>nx_edge_kwargs</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Keword arguments passed to nx.draw_networkx_edges (in addition to G and pos).
If None, we pass {'arrowstyle':'-|&gt;','width':2,'arrowsize':30} by default.</dd>
<dt><strong><code>nx_node_label_kwargs</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Keword arguments passed to nx.draw_networkx_labels (in addition to G and pos).
If None, we pass {'font_size':16} by default.</dd>
<dt><strong><code>nx_edge_label_kwargs</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Keword arguments passed to nx.draw_networkx_edge_labels (in addition to G and pos).
If None, we pass {'font_size':16} by default.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_nx_succession_diagram(G, pos=None, fig_dimensions=(None,None), nx_node_kwargs=None, nx_edge_kwargs=None,
    draw_node_labels=True, labeling_convention=&#39;label&#39;, draw_edge_labels=False, nx_node_label_kwargs=None, nx_edge_label_kwargs=None):
    &#34;&#34;&#34;Plot the input succession diagram. Requires matplotlib. For finer control
    over plot appearance, it is recommended to plot g directly.

    Parameters
    ----------
    G : networkx.DiGraph
        Labeled succession diagram, e.g., as is output from
        export.networkx_succession_diagram_reduced_network_based().
    fig_dimensions : (int,int)
        Dimensions of the output figure. If (None,None), then the dimensions are
        calculated based on the number of nodes in g (the default is (None,None)).
    pos : str or graphviz_layout
        Layout for the nodes; A dictionary with nodes as keys and positions as
        values. Positions should be sequences of length 2. If none, we attempt to
        use pydot/graphviz to construct a layout, otherwise we fall back to the
        networkx planar_layout function (succession diagrams are always planar).
    draw_node_labels : bool
        Whether node labels should be drawn (True) or left as metadata (False)
        (the default is True).
    draw_edge_labels : bool
        Whether edge labels should be drawn (True) or left as metadata (False);
        only affects reduced-network-based (default) succession diagrams, not
        motif-based succession diagrams. (The default value is False.)
    labeling_convention : str
        Whether edge labels should be just the stable motifs (&#39;label&#39;) or all stabilized states (&#39;states&#39;)
        (the default is &#39;label&#39;).
    nx_node_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_nodes (in addition to G and pos).
        If None, we pass {&#39;node_size&#39;:50*G.number_of_nodes()} by default.
    nx_edge_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_edges (in addition to G and pos).
        If None, we pass {&#39;arrowstyle&#39;:&#39;-|&gt;&#39;,&#39;width&#39;:2,&#39;arrowsize&#39;:30} by default.
    nx_node_label_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_labels (in addition to G and pos).
        If None, we pass {&#39;font_size&#39;:16} by default.
    nx_edge_label_kwargs : dictionary
        Keword arguments passed to nx.draw_networkx_edge_labels (in addition to G and pos).
        If None, we pass {&#39;font_size&#39;:16} by default.

    &#34;&#34;&#34;
    import matplotlib.pyplot as plt

    if fig_dimensions == (None,None):
        fig_dimensions=(2*(G.number_of_nodes()+2),G.number_of_nodes()+2)

    if pos is None:
        try:
            from networkx.drawing.nx_agraph import graphviz_layout
            pos = graphviz_layout(G, prog=&#39;dot&#39;)
        except ImportError:
            pos = nx.planar_layout(G)

    plt.figure(figsize=fig_dimensions)

    if nx_node_kwargs is None:
        nx_node_kwargs = {&#39;node_size&#39;:50*G.number_of_nodes()}
    if nx_edge_kwargs is None:
        nx_edge_kwargs = {&#39;arrowstyle&#39;:&#39;-|&gt;&#39;,&#39;width&#39;:2,&#39;arrowsize&#39;:30}
    if nx_node_label_kwargs is None:
        nx_node_label_kwargs = {&#39;font_size&#39;:16}
    if nx_edge_label_kwargs is None:
        nx_edge_label_kwargs = {&#39;font_size&#39;:16}

    nx.drawing.draw_networkx_nodes(G, pos,**nx_node_kwargs)
    nx.draw_networkx_edges(G, pos,**nx_edge_kwargs)
    if draw_node_labels:
        if labeling_convention==&#39;label&#39;:
            nx.drawing.draw_networkx_labels(G,pos, labels=dict(G.nodes(&#39;label&#39;)),**nx_node_label_kwargs)
        else:
            nx.drawing.draw_networkx_labels(G,pos, labels=dict(G.nodes(&#39;states&#39;)),**nx_node_label_kwargs)
    if draw_edge_labels:
        nx.drawing.draw_networkx_edge_labels(G,pos,edge_labels=nx.get_edge_attributes(G,&#39;motif&#39;),**nx_edge_label_kwargs)
    plt.axis(&#39;off&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="pystablemotifs.export.save_to_graphml"><code class="name flex">
<span>def <span class="ident">save_to_graphml</span></span>(<span>G, model_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Export a labeled succesion diagram to graphml format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>networkx.DiGraph</code></dt>
<dd>Labeled succession diagram to export.</dd>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of file to save to (.graphml extension will be appended).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_graphml(G,model_name):
    &#34;&#34;&#34;Export a labeled succesion diagram to graphml format.

    Parameters
    ----------
    G : networkx.DiGraph
        Labeled succession diagram to export.
    model_name : str
        Name of file to save to (.graphml extension will be appended).

    &#34;&#34;&#34;

    #Graphml does not support complex attribues so we create a copy and stringify everything
    G_ex=G.copy()
    for n in G_ex.nodes():
        for k,v in G_ex.nodes[n].items():
            G_ex.nodes[n][k]=str(v)
    for e in G_ex.edges():
        for k,v in G_ex.edges[e].items():
            G_ex.edges[e][k]=str(v)
    nx.write_graphml(G_ex, &#34;%s.graphml&#34;%model_name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pystablemotifs" href="index.html">pystablemotifs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pystablemotifs.export.attractor_dataframe" href="#pystablemotifs.export.attractor_dataframe">attractor_dataframe</a></code></li>
<li><code><a title="pystablemotifs.export.expanded_network" href="#pystablemotifs.export.expanded_network">expanded_network</a></code></li>
<li><code><a title="pystablemotifs.export.networkx_succession_diagram" href="#pystablemotifs.export.networkx_succession_diagram">networkx_succession_diagram</a></code></li>
<li><code><a title="pystablemotifs.export.networkx_succession_diagram_motif_based" href="#pystablemotifs.export.networkx_succession_diagram_motif_based">networkx_succession_diagram_motif_based</a></code></li>
<li><code><a title="pystablemotifs.export.networkx_succession_diagram_reduced_network_based" href="#pystablemotifs.export.networkx_succession_diagram_reduced_network_based">networkx_succession_diagram_reduced_network_based</a></code></li>
<li><code><a title="pystablemotifs.export.plot_nx_succession_diagram" href="#pystablemotifs.export.plot_nx_succession_diagram">plot_nx_succession_diagram</a></code></li>
<li><code><a title="pystablemotifs.export.save_to_graphml" href="#pystablemotifs.export.save_to_graphml">save_to_graphml</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>